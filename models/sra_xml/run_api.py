#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Mar 13 15:45:11 2017 by generateDS.py version 2.16a.
#
# Command line options:
#   ('-f', '')
#   ('-o', 'run_api.py')
#
# Command line arguments:
#   sra_schema_files/SRA.run.xsd
#
# Command line:
#   /home/gemmy/generateDS-2.16a0/generateDS.py -f -o "run_api.py" sra_schema_files/SRA.run.xsd
#
# Current working directory (os.getcwd()):
#   sra_xml
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class RunSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RUN=None):
        self.original_tagname_ = None
        if RUN is None:
            self.RUN = []
        else:
            self.RUN = RUN
    def factory(*args_, **kwargs_):
        if RunSetType.subclass:
            return RunSetType.subclass(*args_, **kwargs_)
        else:
            return RunSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RUN(self): return self.RUN
    def set_RUN(self, RUN): self.RUN = RUN
    def add_RUN(self, value): self.RUN.append(value)
    def insert_RUN_at(self, index, value): self.RUN.insert(index, value)
    def replace_RUN_at(self, index, value): self.RUN[index] = value
    def hasContent_(self):
        if (
            self.RUN
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RunSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RunSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RunSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RunSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RunSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RUN_ in self.RUN:
            RUN_.export(outfile, level, namespace_, name_='RUN', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RunSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RUN=[\n')
        level += 1
        for RUN_ in self.RUN:
            showIndent(outfile, level)
            outfile.write('model_.RunType(\n')
            RUN_.exportLiteral(outfile, level, name_='RunType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RUN':
            obj_ = RunType.factory()
            obj_.build(child_)
            self.RUN.append(obj_)
            obj_.original_tagname_ = 'RUN'
# end class RunSetType


class ObjectType(GeneratedsSuper):
    """Submitter designated name for the object. The name must be unique
    within the submission account. The center name of the submitter.
    The center name of the broker. The object accession assigned by
    the archive."""
    subclass = None
    superclass = None
    def __init__(self, center_name=None, alias=None, broker_name=None, accession=None, IDENTIFIERS=None, extensiontype_=None):
        self.original_tagname_ = None
        self.center_name = _cast(None, center_name)
        self.alias = _cast(None, alias)
        self.broker_name = _cast(None, broker_name)
        self.accession = _cast(None, accession)
        self.IDENTIFIERS = IDENTIFIERS
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ObjectType.subclass:
            return ObjectType.subclass(*args_, **kwargs_)
        else:
            return ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IDENTIFIERS(self): return self.IDENTIFIERS
    def set_IDENTIFIERS(self, IDENTIFIERS): self.IDENTIFIERS = IDENTIFIERS
    def get_center_name(self): return self.center_name
    def set_center_name(self, center_name): self.center_name = center_name
    def get_alias(self): return self.alias
    def set_alias(self, alias): self.alias = alias
    def get_broker_name(self): return self.broker_name
    def set_broker_name(self, broker_name): self.broker_name = broker_name
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObjectType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectType'):
        if self.center_name is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            outfile.write(' center_name=%s' % (self.gds_format_string(quote_attrib(self.center_name).encode(ExternalEncoding), input_name='center_name'), ))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (self.gds_format_string(quote_attrib(self.alias).encode(ExternalEncoding), input_name='alias'), ))
        if self.broker_name is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            outfile.write(' broker_name=%s' % (self.gds_format_string(quote_attrib(self.broker_name).encode(ExternalEncoding), input_name='broker_name'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.center_name is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            showIndent(outfile, level)
            outfile.write('center_name="%s",\n' % (self.center_name,))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            showIndent(outfile, level)
            outfile.write('alias="%s",\n' % (self.alias,))
        if self.broker_name is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            showIndent(outfile, level)
            outfile.write('broker_name="%s",\n' % (self.broker_name,))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IDENTIFIERS is not None:
            showIndent(outfile, level)
            outfile.write('IDENTIFIERS=model_.IdentifierType(\n')
            self.IDENTIFIERS.exportLiteral(outfile, level, name_='IDENTIFIERS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('center_name', node)
        if value is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            self.center_name = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('broker_name', node)
        if value is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            self.broker_name = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'
# end class ObjectType


class RefObjectType(GeneratedsSuper):
    """Identifies an object by name within the namespace defined by
    attribute "refcenter". The namespace of the attribute "refname".
    Identifies a record by its accession. The scope of resolution is
    the entire Archive."""
    subclass = None
    superclass = None
    def __init__(self, accession=None, refname=None, refcenter=None, IDENTIFIERS=None, extensiontype_=None):
        self.original_tagname_ = None
        self.accession = _cast(None, accession)
        self.refname = _cast(None, refname)
        self.refcenter = _cast(None, refcenter)
        self.IDENTIFIERS = IDENTIFIERS
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if RefObjectType.subclass:
            return RefObjectType.subclass(*args_, **kwargs_)
        else:
            return RefObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IDENTIFIERS(self): return self.IDENTIFIERS
    def set_IDENTIFIERS(self, IDENTIFIERS): self.IDENTIFIERS = IDENTIFIERS
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def get_refname(self): return self.refname
    def set_refname(self, refname): self.refname = refname
    def get_refcenter(self): return self.refcenter
    def set_refcenter(self, refcenter): self.refcenter = refcenter
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RefObjectType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RefObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RefObjectType'):
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding), input_name='refname'), ))
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            outfile.write(' refcenter=%s' % (self.gds_format_string(quote_attrib(self.refcenter).encode(ExternalEncoding), input_name='refcenter'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='RefObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RefObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            showIndent(outfile, level)
            outfile.write('refname="%s",\n' % (self.refname,))
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            showIndent(outfile, level)
            outfile.write('refcenter="%s",\n' % (self.refcenter,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IDENTIFIERS is not None:
            showIndent(outfile, level)
            outfile.write('IDENTIFIERS=model_.IdentifierType(\n')
            self.IDENTIFIERS.exportLiteral(outfile, level, name_='IDENTIFIERS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('refcenter', node)
        if value is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            self.refcenter = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'
# end class RefObjectType


class NameType(GeneratedsSuper):
    """Alternative/explanatory description of the same object/identifier."""
    subclass = None
    superclass = None
    def __init__(self, label=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if NameType.subclass:
            return NameType.subclass(*args_, **kwargs_)
        else:
            return NameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameType'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NameType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='NameType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            showIndent(outfile, level)
            outfile.write('label="%s",\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameType


class QualifiedNameType(NameType):
    """A string value that constrains the domain of named identifiers
    (namespace)."""
    subclass = None
    superclass = NameType
    def __init__(self, label=None, namespace=None, valueOf_=None):
        self.original_tagname_ = None
        super(QualifiedNameType, self).__init__(label, valueOf_, )
        self.namespace = _cast(None, namespace)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if QualifiedNameType.subclass:
            return QualifiedNameType.subclass(*args_, **kwargs_)
        else:
            return QualifiedNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(QualifiedNameType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QualifiedNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QualifiedNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QualifiedNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QualifiedNameType'):
        super(QualifiedNameType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QualifiedNameType')
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            outfile.write(' namespace=%s' % (self.gds_format_string(quote_attrib(self.namespace).encode(ExternalEncoding), input_name='namespace'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QualifiedNameType', fromsubclass_=False, pretty_print=True):
        super(QualifiedNameType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='QualifiedNameType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            showIndent(outfile, level)
            outfile.write('namespace="%s",\n' % (self.namespace,))
        super(QualifiedNameType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QualifiedNameType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('namespace', node)
        if value is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            self.namespace = value
        super(QualifiedNameType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QualifiedNameType


class IdentifierType(GeneratedsSuper):
    """Set of record identifiers."""
    subclass = None
    superclass = None
    def __init__(self, PRIMARY_ID=None, SECONDARY_ID=None, EXTERNAL_ID=None, SUBMITTER_ID=None, UUID=None):
        self.original_tagname_ = None
        self.PRIMARY_ID = PRIMARY_ID
        if SECONDARY_ID is None:
            self.SECONDARY_ID = []
        else:
            self.SECONDARY_ID = SECONDARY_ID
        if EXTERNAL_ID is None:
            self.EXTERNAL_ID = []
        else:
            self.EXTERNAL_ID = EXTERNAL_ID
        self.SUBMITTER_ID = SUBMITTER_ID
        if UUID is None:
            self.UUID = []
        else:
            self.UUID = UUID
    def factory(*args_, **kwargs_):
        if IdentifierType.subclass:
            return IdentifierType.subclass(*args_, **kwargs_)
        else:
            return IdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PRIMARY_ID(self): return self.PRIMARY_ID
    def set_PRIMARY_ID(self, PRIMARY_ID): self.PRIMARY_ID = PRIMARY_ID
    def get_SECONDARY_ID(self): return self.SECONDARY_ID
    def set_SECONDARY_ID(self, SECONDARY_ID): self.SECONDARY_ID = SECONDARY_ID
    def add_SECONDARY_ID(self, value): self.SECONDARY_ID.append(value)
    def insert_SECONDARY_ID_at(self, index, value): self.SECONDARY_ID.insert(index, value)
    def replace_SECONDARY_ID_at(self, index, value): self.SECONDARY_ID[index] = value
    def get_EXTERNAL_ID(self): return self.EXTERNAL_ID
    def set_EXTERNAL_ID(self, EXTERNAL_ID): self.EXTERNAL_ID = EXTERNAL_ID
    def add_EXTERNAL_ID(self, value): self.EXTERNAL_ID.append(value)
    def insert_EXTERNAL_ID_at(self, index, value): self.EXTERNAL_ID.insert(index, value)
    def replace_EXTERNAL_ID_at(self, index, value): self.EXTERNAL_ID[index] = value
    def get_SUBMITTER_ID(self): return self.SUBMITTER_ID
    def set_SUBMITTER_ID(self, SUBMITTER_ID): self.SUBMITTER_ID = SUBMITTER_ID
    def get_UUID(self): return self.UUID
    def set_UUID(self, UUID): self.UUID = UUID
    def add_UUID(self, value): self.UUID.append(value)
    def insert_UUID_at(self, index, value): self.UUID.insert(index, value)
    def replace_UUID_at(self, index, value): self.UUID[index] = value
    def hasContent_(self):
        if (
            self.PRIMARY_ID is not None or
            self.SECONDARY_ID or
            self.EXTERNAL_ID or
            self.SUBMITTER_ID is not None or
            self.UUID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifierType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PRIMARY_ID is not None:
            self.PRIMARY_ID.export(outfile, level, namespace_, name_='PRIMARY_ID', pretty_print=pretty_print)
        for SECONDARY_ID_ in self.SECONDARY_ID:
            SECONDARY_ID_.export(outfile, level, namespace_, name_='SECONDARY_ID', pretty_print=pretty_print)
        for EXTERNAL_ID_ in self.EXTERNAL_ID:
            EXTERNAL_ID_.export(outfile, level, namespace_, name_='EXTERNAL_ID', pretty_print=pretty_print)
        if self.SUBMITTER_ID is not None:
            self.SUBMITTER_ID.export(outfile, level, namespace_, name_='SUBMITTER_ID', pretty_print=pretty_print)
        for UUID_ in self.UUID:
            UUID_.export(outfile, level, namespace_, name_='UUID', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IdentifierType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PRIMARY_ID is not None:
            showIndent(outfile, level)
            outfile.write('PRIMARY_ID=model_.NameType(\n')
            self.PRIMARY_ID.exportLiteral(outfile, level, name_='PRIMARY_ID')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SECONDARY_ID=[\n')
        level += 1
        for SECONDARY_ID_ in self.SECONDARY_ID:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            SECONDARY_ID_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EXTERNAL_ID=[\n')
        level += 1
        for EXTERNAL_ID_ in self.EXTERNAL_ID:
            showIndent(outfile, level)
            outfile.write('model_.QualifiedNameType(\n')
            EXTERNAL_ID_.exportLiteral(outfile, level, name_='QualifiedNameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SUBMITTER_ID is not None:
            showIndent(outfile, level)
            outfile.write('SUBMITTER_ID=model_.QualifiedNameType(\n')
            self.SUBMITTER_ID.exportLiteral(outfile, level, name_='SUBMITTER_ID')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('UUID=[\n')
        level += 1
        for UUID_ in self.UUID:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            UUID_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PRIMARY_ID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.PRIMARY_ID = obj_
            obj_.original_tagname_ = 'PRIMARY_ID'
        elif nodeName_ == 'SECONDARY_ID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SECONDARY_ID.append(obj_)
            obj_.original_tagname_ = 'SECONDARY_ID'
        elif nodeName_ == 'EXTERNAL_ID':
            obj_ = QualifiedNameType.factory()
            obj_.build(child_)
            self.EXTERNAL_ID.append(obj_)
            obj_.original_tagname_ = 'EXTERNAL_ID'
        elif nodeName_ == 'SUBMITTER_ID':
            obj_ = QualifiedNameType.factory()
            obj_.build(child_)
            self.SUBMITTER_ID = obj_
            obj_.original_tagname_ = 'SUBMITTER_ID'
        elif nodeName_ == 'UUID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.UUID.append(obj_)
            obj_.original_tagname_ = 'UUID'
# end class IdentifierType


class XRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DB=None, ID=None, LABEL=None):
        self.original_tagname_ = None
        self.DB = DB
        self.ID = ID
        self.LABEL = LABEL
    def factory(*args_, **kwargs_):
        if XRefType.subclass:
            return XRefType.subclass(*args_, **kwargs_)
        else:
            return XRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DB(self): return self.DB
    def set_DB(self, DB): self.DB = DB
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def hasContent_(self):
        if (
            self.DB is not None or
            self.ID is not None or
            self.LABEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='XRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='XRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB>%s</%sDB>%s' % (namespace_, self.gds_format_string(quote_xml(self.DB).encode(ExternalEncoding), input_name='DB'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='XRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DB is not None:
            showIndent(outfile, level)
            outfile.write('DB=%s,\n' % quote_python(self.DB).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.LABEL is not None:
            showIndent(outfile, level)
            outfile.write('LABEL=%s,\n' % quote_python(self.LABEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DB':
            DB_ = child_.text
            DB_ = self.gds_validate_string(DB_, node, 'DB')
            self.DB = DB_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
# end class XRefType


class URLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL
    def factory(*args_, **kwargs_):
        if URLType.subclass:
            return URLType.subclass(*args_, **kwargs_)
        else:
            return URLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def hasContent_(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='URLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URLType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='URLType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LABEL is not None:
            showIndent(outfile, level)
            outfile.write('LABEL=%s,\n' % quote_python(self.LABEL).encode(ExternalEncoding))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URLType


class AttributeType(GeneratedsSuper):
    """Reusable attributes to encode tag-value pairs with optional units."""
    subclass = None
    superclass = None
    def __init__(self, TAG=None, VALUE=None, UNITS=None):
        self.original_tagname_ = None
        self.TAG = TAG
        self.VALUE = VALUE
        self.UNITS = UNITS
    def factory(*args_, **kwargs_):
        if AttributeType.subclass:
            return AttributeType.subclass(*args_, **kwargs_)
        else:
            return AttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TAG(self): return self.TAG
    def set_TAG(self, TAG): self.TAG = TAG
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def get_UNITS(self): return self.UNITS
    def set_UNITS(self, UNITS): self.UNITS = UNITS
    def hasContent_(self):
        if (
            self.TAG is not None or
            self.VALUE is not None or
            self.UNITS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TAG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAG>%s</%sTAG>%s' % (namespace_, self.gds_format_string(quote_xml(self.TAG).encode(ExternalEncoding), input_name='TAG'), namespace_, eol_))
        if self.VALUE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVALUE>%s</%sVALUE>%s' % (namespace_, self.gds_format_string(quote_xml(self.VALUE).encode(ExternalEncoding), input_name='VALUE'), namespace_, eol_))
        if self.UNITS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNITS>%s</%sUNITS>%s' % (namespace_, self.gds_format_string(quote_xml(self.UNITS).encode(ExternalEncoding), input_name='UNITS'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AttributeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TAG is not None:
            showIndent(outfile, level)
            outfile.write('TAG=%s,\n' % quote_python(self.TAG).encode(ExternalEncoding))
        if self.VALUE is not None:
            showIndent(outfile, level)
            outfile.write('VALUE=%s,\n' % quote_python(self.VALUE).encode(ExternalEncoding))
        if self.UNITS is not None:
            showIndent(outfile, level)
            outfile.write('UNITS=%s,\n' % quote_python(self.UNITS).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TAG':
            TAG_ = child_.text
            TAG_ = self.gds_validate_string(TAG_, node, 'TAG')
            self.TAG = TAG_
        elif nodeName_ == 'VALUE':
            VALUE_ = child_.text
            VALUE_ = self.gds_validate_string(VALUE_, node, 'VALUE')
            self.VALUE = VALUE_
        elif nodeName_ == 'UNITS':
            UNITS_ = child_.text
            UNITS_ = self.gds_validate_string(UNITS_, node, 'UNITS')
            self.UNITS = UNITS_
# end class AttributeType


class LinkType(GeneratedsSuper):
    """Reusable external links type to encode URL links, Entrez links, and
    db_xref links."""
    subclass = None
    superclass = None
    def __init__(self, URL_LINK=None, XREF_LINK=None, ENTREZ_LINK=None):
        self.original_tagname_ = None
        self.URL_LINK = URL_LINK
        self.XREF_LINK = XREF_LINK
        self.ENTREZ_LINK = ENTREZ_LINK
    def factory(*args_, **kwargs_):
        if LinkType.subclass:
            return LinkType.subclass(*args_, **kwargs_)
        else:
            return LinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL_LINK(self): return self.URL_LINK
    def set_URL_LINK(self, URL_LINK): self.URL_LINK = URL_LINK
    def get_XREF_LINK(self): return self.XREF_LINK
    def set_XREF_LINK(self, XREF_LINK): self.XREF_LINK = XREF_LINK
    def get_ENTREZ_LINK(self): return self.ENTREZ_LINK
    def set_ENTREZ_LINK(self, ENTREZ_LINK): self.ENTREZ_LINK = ENTREZ_LINK
    def hasContent_(self):
        if (
            self.URL_LINK is not None or
            self.XREF_LINK is not None or
            self.ENTREZ_LINK is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URL_LINK is not None:
            self.URL_LINK.export(outfile, level, namespace_, name_='URL_LINK', pretty_print=pretty_print)
        if self.XREF_LINK is not None:
            self.XREF_LINK.export(outfile, level, namespace_, name_='XREF_LINK', pretty_print=pretty_print)
        if self.ENTREZ_LINK is not None:
            self.ENTREZ_LINK.export(outfile, level, namespace_, name_='ENTREZ_LINK', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LinkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URL_LINK is not None:
            showIndent(outfile, level)
            outfile.write('URL_LINK=model_.URL_LINKType(\n')
            self.URL_LINK.exportLiteral(outfile, level, name_='URL_LINK')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.XREF_LINK is not None:
            showIndent(outfile, level)
            outfile.write('XREF_LINK=model_.XRefType(\n')
            self.XREF_LINK.exportLiteral(outfile, level, name_='XREF_LINK')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ENTREZ_LINK is not None:
            showIndent(outfile, level)
            outfile.write('ENTREZ_LINK=model_.ENTREZ_LINKType(\n')
            self.ENTREZ_LINK.exportLiteral(outfile, level, name_='ENTREZ_LINK')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL_LINK':
            obj_ = URL_LINKType.factory()
            obj_.build(child_)
            self.URL_LINK = obj_
            obj_.original_tagname_ = 'URL_LINK'
        elif nodeName_ == 'XREF_LINK':
            obj_ = XRefType.factory()
            obj_.build(child_)
            self.XREF_LINK = obj_
            obj_.original_tagname_ = 'XREF_LINK'
        elif nodeName_ == 'ENTREZ_LINK':
            obj_ = ENTREZ_LINKType.factory()
            obj_.build(child_)
            self.ENTREZ_LINK = obj_
            obj_.original_tagname_ = 'ENTREZ_LINK'
# end class LinkType


class SpotDescriptorType(GeneratedsSuper):
    """The SPOT_DESCRIPTOR specifies how to decode the individual reads of
    interest from the monolithic spot sequence. The spot descriptor
    contains aspects of the experimental design, platform, and
    processing information. There will be two methods of
    specification: one will be an index into a table of typical
    decodings, the other being an exact specification."""
    subclass = None
    superclass = None
    def __init__(self, SPOT_DECODE_SPEC=None):
        self.original_tagname_ = None
        self.SPOT_DECODE_SPEC = SPOT_DECODE_SPEC
    def factory(*args_, **kwargs_):
        if SpotDescriptorType.subclass:
            return SpotDescriptorType.subclass(*args_, **kwargs_)
        else:
            return SpotDescriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SPOT_DECODE_SPEC(self): return self.SPOT_DECODE_SPEC
    def set_SPOT_DECODE_SPEC(self, SPOT_DECODE_SPEC): self.SPOT_DECODE_SPEC = SPOT_DECODE_SPEC
    def hasContent_(self):
        if (
            self.SPOT_DECODE_SPEC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpotDescriptorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpotDescriptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpotDescriptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpotDescriptorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpotDescriptorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SPOT_DECODE_SPEC is not None:
            self.SPOT_DECODE_SPEC.export(outfile, level, namespace_, name_='SPOT_DECODE_SPEC', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SpotDescriptorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SPOT_DECODE_SPEC is not None:
            showIndent(outfile, level)
            outfile.write('SPOT_DECODE_SPEC=model_.SPOT_DECODE_SPECType(\n')
            self.SPOT_DECODE_SPEC.exportLiteral(outfile, level, name_='SPOT_DECODE_SPEC')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SPOT_DECODE_SPEC':
            obj_ = SPOT_DECODE_SPECType.factory()
            obj_.build(child_)
            self.SPOT_DECODE_SPEC = obj_
            obj_.original_tagname_ = 'SPOT_DECODE_SPEC'
# end class SpotDescriptorType


class PlatformType(GeneratedsSuper):
    """The PLATFORM record selects which sequencing platform and platform-
    specific runtime parameters. This will be determined by the
    Center."""
    subclass = None
    superclass = None
    def __init__(self, LS454=None, ILLUMINA=None, HELICOS=None, ABI_SOLID=None, COMPLETE_GENOMICS=None, BGISEQ=None, OXFORD_NANOPORE=None, PACBIO_SMRT=None, ION_TORRENT=None, CAPILLARY=None):
        self.original_tagname_ = None
        self.LS454 = LS454
        self.ILLUMINA = ILLUMINA
        self.HELICOS = HELICOS
        self.ABI_SOLID = ABI_SOLID
        self.COMPLETE_GENOMICS = COMPLETE_GENOMICS
        self.BGISEQ = BGISEQ
        self.OXFORD_NANOPORE = OXFORD_NANOPORE
        self.PACBIO_SMRT = PACBIO_SMRT
        self.ION_TORRENT = ION_TORRENT
        self.CAPILLARY = CAPILLARY
    def factory(*args_, **kwargs_):
        if PlatformType.subclass:
            return PlatformType.subclass(*args_, **kwargs_)
        else:
            return PlatformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LS454(self): return self.LS454
    def set_LS454(self, LS454): self.LS454 = LS454
    def get_ILLUMINA(self): return self.ILLUMINA
    def set_ILLUMINA(self, ILLUMINA): self.ILLUMINA = ILLUMINA
    def get_HELICOS(self): return self.HELICOS
    def set_HELICOS(self, HELICOS): self.HELICOS = HELICOS
    def get_ABI_SOLID(self): return self.ABI_SOLID
    def set_ABI_SOLID(self, ABI_SOLID): self.ABI_SOLID = ABI_SOLID
    def get_COMPLETE_GENOMICS(self): return self.COMPLETE_GENOMICS
    def set_COMPLETE_GENOMICS(self, COMPLETE_GENOMICS): self.COMPLETE_GENOMICS = COMPLETE_GENOMICS
    def get_BGISEQ(self): return self.BGISEQ
    def set_BGISEQ(self, BGISEQ): self.BGISEQ = BGISEQ
    def get_OXFORD_NANOPORE(self): return self.OXFORD_NANOPORE
    def set_OXFORD_NANOPORE(self, OXFORD_NANOPORE): self.OXFORD_NANOPORE = OXFORD_NANOPORE
    def get_PACBIO_SMRT(self): return self.PACBIO_SMRT
    def set_PACBIO_SMRT(self, PACBIO_SMRT): self.PACBIO_SMRT = PACBIO_SMRT
    def get_ION_TORRENT(self): return self.ION_TORRENT
    def set_ION_TORRENT(self, ION_TORRENT): self.ION_TORRENT = ION_TORRENT
    def get_CAPILLARY(self): return self.CAPILLARY
    def set_CAPILLARY(self, CAPILLARY): self.CAPILLARY = CAPILLARY
    def hasContent_(self):
        if (
            self.LS454 is not None or
            self.ILLUMINA is not None or
            self.HELICOS is not None or
            self.ABI_SOLID is not None or
            self.COMPLETE_GENOMICS is not None or
            self.BGISEQ is not None or
            self.OXFORD_NANOPORE is not None or
            self.PACBIO_SMRT is not None or
            self.ION_TORRENT is not None or
            self.CAPILLARY is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PlatformType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PlatformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlatformType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PlatformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LS454 is not None:
            self.LS454.export(outfile, level, namespace_, name_='LS454', pretty_print=pretty_print)
        if self.ILLUMINA is not None:
            self.ILLUMINA.export(outfile, level, namespace_, name_='ILLUMINA', pretty_print=pretty_print)
        if self.HELICOS is not None:
            self.HELICOS.export(outfile, level, namespace_, name_='HELICOS', pretty_print=pretty_print)
        if self.ABI_SOLID is not None:
            self.ABI_SOLID.export(outfile, level, namespace_, name_='ABI_SOLID', pretty_print=pretty_print)
        if self.COMPLETE_GENOMICS is not None:
            self.COMPLETE_GENOMICS.export(outfile, level, namespace_, name_='COMPLETE_GENOMICS', pretty_print=pretty_print)
        if self.BGISEQ is not None:
            self.BGISEQ.export(outfile, level, namespace_, name_='BGISEQ', pretty_print=pretty_print)
        if self.OXFORD_NANOPORE is not None:
            self.OXFORD_NANOPORE.export(outfile, level, namespace_, name_='OXFORD_NANOPORE', pretty_print=pretty_print)
        if self.PACBIO_SMRT is not None:
            self.PACBIO_SMRT.export(outfile, level, namespace_, name_='PACBIO_SMRT', pretty_print=pretty_print)
        if self.ION_TORRENT is not None:
            self.ION_TORRENT.export(outfile, level, namespace_, name_='ION_TORRENT', pretty_print=pretty_print)
        if self.CAPILLARY is not None:
            self.CAPILLARY.export(outfile, level, namespace_, name_='CAPILLARY', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PlatformType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LS454 is not None:
            showIndent(outfile, level)
            outfile.write('LS454=model_.LS454Type(\n')
            self.LS454.exportLiteral(outfile, level, name_='LS454')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ILLUMINA is not None:
            showIndent(outfile, level)
            outfile.write('ILLUMINA=model_.ILLUMINAType(\n')
            self.ILLUMINA.exportLiteral(outfile, level, name_='ILLUMINA')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HELICOS is not None:
            showIndent(outfile, level)
            outfile.write('HELICOS=model_.HELICOSType(\n')
            self.HELICOS.exportLiteral(outfile, level, name_='HELICOS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ABI_SOLID is not None:
            showIndent(outfile, level)
            outfile.write('ABI_SOLID=model_.ABI_SOLIDType(\n')
            self.ABI_SOLID.exportLiteral(outfile, level, name_='ABI_SOLID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.COMPLETE_GENOMICS is not None:
            showIndent(outfile, level)
            outfile.write('COMPLETE_GENOMICS=model_.COMPLETE_GENOMICSType(\n')
            self.COMPLETE_GENOMICS.exportLiteral(outfile, level, name_='COMPLETE_GENOMICS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BGISEQ is not None:
            showIndent(outfile, level)
            outfile.write('BGISEQ=model_.BGISEQType(\n')
            self.BGISEQ.exportLiteral(outfile, level, name_='BGISEQ')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OXFORD_NANOPORE is not None:
            showIndent(outfile, level)
            outfile.write('OXFORD_NANOPORE=model_.OXFORD_NANOPOREType(\n')
            self.OXFORD_NANOPORE.exportLiteral(outfile, level, name_='OXFORD_NANOPORE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PACBIO_SMRT is not None:
            showIndent(outfile, level)
            outfile.write('PACBIO_SMRT=model_.PACBIO_SMRTType(\n')
            self.PACBIO_SMRT.exportLiteral(outfile, level, name_='PACBIO_SMRT')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ION_TORRENT is not None:
            showIndent(outfile, level)
            outfile.write('ION_TORRENT=model_.ION_TORRENTType(\n')
            self.ION_TORRENT.exportLiteral(outfile, level, name_='ION_TORRENT')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CAPILLARY is not None:
            showIndent(outfile, level)
            outfile.write('CAPILLARY=model_.CAPILLARYType(\n')
            self.CAPILLARY.exportLiteral(outfile, level, name_='CAPILLARY')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LS454':
            obj_ = LS454Type.factory()
            obj_.build(child_)
            self.LS454 = obj_
            obj_.original_tagname_ = 'LS454'
        elif nodeName_ == 'ILLUMINA':
            obj_ = ILLUMINAType.factory()
            obj_.build(child_)
            self.ILLUMINA = obj_
            obj_.original_tagname_ = 'ILLUMINA'
        elif nodeName_ == 'HELICOS':
            obj_ = HELICOSType.factory()
            obj_.build(child_)
            self.HELICOS = obj_
            obj_.original_tagname_ = 'HELICOS'
        elif nodeName_ == 'ABI_SOLID':
            obj_ = ABI_SOLIDType.factory()
            obj_.build(child_)
            self.ABI_SOLID = obj_
            obj_.original_tagname_ = 'ABI_SOLID'
        elif nodeName_ == 'COMPLETE_GENOMICS':
            obj_ = COMPLETE_GENOMICSType.factory()
            obj_.build(child_)
            self.COMPLETE_GENOMICS = obj_
            obj_.original_tagname_ = 'COMPLETE_GENOMICS'
        elif nodeName_ == 'BGISEQ':
            obj_ = BGISEQType.factory()
            obj_.build(child_)
            self.BGISEQ = obj_
            obj_.original_tagname_ = 'BGISEQ'
        elif nodeName_ == 'OXFORD_NANOPORE':
            obj_ = OXFORD_NANOPOREType.factory()
            obj_.build(child_)
            self.OXFORD_NANOPORE = obj_
            obj_.original_tagname_ = 'OXFORD_NANOPORE'
        elif nodeName_ == 'PACBIO_SMRT':
            obj_ = PACBIO_SMRTType.factory()
            obj_.build(child_)
            self.PACBIO_SMRT = obj_
            obj_.original_tagname_ = 'PACBIO_SMRT'
        elif nodeName_ == 'ION_TORRENT':
            obj_ = ION_TORRENTType.factory()
            obj_.build(child_)
            self.ION_TORRENT = obj_
            obj_.original_tagname_ = 'ION_TORRENT'
        elif nodeName_ == 'CAPILLARY':
            obj_ = CAPILLARYType.factory()
            obj_.build(child_)
            self.CAPILLARY = obj_
            obj_.original_tagname_ = 'CAPILLARY'
# end class PlatformType


class SequencingDirectivesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SAMPLE_DEMUX_DIRECTIVE=None):
        self.original_tagname_ = None
        self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE
        self.validate_SAMPLE_DEMUX_DIRECTIVEType(self.SAMPLE_DEMUX_DIRECTIVE)
    def factory(*args_, **kwargs_):
        if SequencingDirectivesType.subclass:
            return SequencingDirectivesType.subclass(*args_, **kwargs_)
        else:
            return SequencingDirectivesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SAMPLE_DEMUX_DIRECTIVE(self): return self.SAMPLE_DEMUX_DIRECTIVE
    def set_SAMPLE_DEMUX_DIRECTIVE(self, SAMPLE_DEMUX_DIRECTIVE): self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE
    def validate_SAMPLE_DEMUX_DIRECTIVEType(self, value):
        # Validate type SAMPLE_DEMUX_DIRECTIVEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['leave_as_pool', 'submitter_demultiplexed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SAMPLE_DEMUX_DIRECTIVEType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SAMPLE_DEMUX_DIRECTIVE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SequencingDirectivesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequencingDirectivesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SequencingDirectivesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequencingDirectivesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SequencingDirectivesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SAMPLE_DEMUX_DIRECTIVE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSAMPLE_DEMUX_DIRECTIVE>%s</%sSAMPLE_DEMUX_DIRECTIVE>%s' % (namespace_, self.gds_format_string(quote_xml(self.SAMPLE_DEMUX_DIRECTIVE).encode(ExternalEncoding), input_name='SAMPLE_DEMUX_DIRECTIVE'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SequencingDirectivesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SAMPLE_DEMUX_DIRECTIVE is not None:
            showIndent(outfile, level)
            outfile.write('SAMPLE_DEMUX_DIRECTIVE=%s,\n' % quote_python(self.SAMPLE_DEMUX_DIRECTIVE).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SAMPLE_DEMUX_DIRECTIVE':
            SAMPLE_DEMUX_DIRECTIVE_ = child_.text
            SAMPLE_DEMUX_DIRECTIVE_ = self.gds_validate_string(SAMPLE_DEMUX_DIRECTIVE_, node, 'SAMPLE_DEMUX_DIRECTIVE')
            self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE_
            # validate type SAMPLE_DEMUX_DIRECTIVEType
            self.validate_SAMPLE_DEMUX_DIRECTIVEType(self.SAMPLE_DEMUX_DIRECTIVE)
# end class SequencingDirectivesType


class PipelineType(GeneratedsSuper):
    """The PipelineType identifies the sequence or tree of actions to
    process the sequencing data."""
    subclass = None
    superclass = None
    def __init__(self, PIPE_SECTION=None):
        self.original_tagname_ = None
        if PIPE_SECTION is None:
            self.PIPE_SECTION = []
        else:
            self.PIPE_SECTION = PIPE_SECTION
    def factory(*args_, **kwargs_):
        if PipelineType.subclass:
            return PipelineType.subclass(*args_, **kwargs_)
        else:
            return PipelineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PIPE_SECTION(self): return self.PIPE_SECTION
    def set_PIPE_SECTION(self, PIPE_SECTION): self.PIPE_SECTION = PIPE_SECTION
    def add_PIPE_SECTION(self, value): self.PIPE_SECTION.append(value)
    def insert_PIPE_SECTION_at(self, index, value): self.PIPE_SECTION.insert(index, value)
    def replace_PIPE_SECTION_at(self, index, value): self.PIPE_SECTION[index] = value
    def hasContent_(self):
        if (
            self.PIPE_SECTION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PipelineType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipelineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PipelineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PipelineType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PipelineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PIPE_SECTION_ in self.PIPE_SECTION:
            PIPE_SECTION_.export(outfile, level, namespace_, name_='PIPE_SECTION', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PipelineType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PIPE_SECTION=[\n')
        level += 1
        for PIPE_SECTION_ in self.PIPE_SECTION:
            showIndent(outfile, level)
            outfile.write('model_.PIPE_SECTIONType(\n')
            PIPE_SECTION_.exportLiteral(outfile, level, name_='PIPE_SECTIONType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PIPE_SECTION':
            obj_ = PIPE_SECTIONType.factory()
            obj_.build(child_)
            self.PIPE_SECTION.append(obj_)
            obj_.original_tagname_ = 'PIPE_SECTION'
# end class PipelineType


class ReferenceAssemblyType(GeneratedsSuper):
    """Reference assembly details."""
    subclass = None
    superclass = None
    def __init__(self, STANDARD=None, CUSTOM=None):
        self.original_tagname_ = None
        self.STANDARD = STANDARD
        self.CUSTOM = CUSTOM
    def factory(*args_, **kwargs_):
        if ReferenceAssemblyType.subclass:
            return ReferenceAssemblyType.subclass(*args_, **kwargs_)
        else:
            return ReferenceAssemblyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STANDARD(self): return self.STANDARD
    def set_STANDARD(self, STANDARD): self.STANDARD = STANDARD
    def get_CUSTOM(self): return self.CUSTOM
    def set_CUSTOM(self, CUSTOM): self.CUSTOM = CUSTOM
    def hasContent_(self):
        if (
            self.STANDARD is not None or
            self.CUSTOM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceAssemblyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceAssemblyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceAssemblyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceAssemblyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceAssemblyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STANDARD is not None:
            self.STANDARD.export(outfile, level, namespace_, name_='STANDARD', pretty_print=pretty_print)
        if self.CUSTOM is not None:
            self.CUSTOM.export(outfile, level, namespace_, name_='CUSTOM', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceAssemblyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.STANDARD is not None:
            showIndent(outfile, level)
            outfile.write('STANDARD=model_.STANDARDType(\n')
            self.STANDARD.exportLiteral(outfile, level, name_='STANDARD')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CUSTOM is not None:
            showIndent(outfile, level)
            outfile.write('CUSTOM=model_.CUSTOMType(\n')
            self.CUSTOM.exportLiteral(outfile, level, name_='CUSTOM')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STANDARD':
            obj_ = STANDARDType.factory()
            obj_.build(child_)
            self.STANDARD = obj_
            obj_.original_tagname_ = 'STANDARD'
        elif nodeName_ == 'CUSTOM':
            obj_ = CUSTOMType.factory()
            obj_.build(child_)
            self.CUSTOM = obj_
            obj_.original_tagname_ = 'CUSTOM'
# end class ReferenceAssemblyType


class ReferenceSequenceType(GeneratedsSuper):
    """Reference assembly and sequence details."""
    subclass = None
    superclass = None
    def __init__(self, ASSEMBLY=None, SEQUENCE=None):
        self.original_tagname_ = None
        self.ASSEMBLY = ASSEMBLY
        if SEQUENCE is None:
            self.SEQUENCE = []
        else:
            self.SEQUENCE = SEQUENCE
    def factory(*args_, **kwargs_):
        if ReferenceSequenceType.subclass:
            return ReferenceSequenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceSequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ASSEMBLY(self): return self.ASSEMBLY
    def set_ASSEMBLY(self, ASSEMBLY): self.ASSEMBLY = ASSEMBLY
    def get_SEQUENCE(self): return self.SEQUENCE
    def set_SEQUENCE(self, SEQUENCE): self.SEQUENCE = SEQUENCE
    def add_SEQUENCE(self, value): self.SEQUENCE.append(value)
    def insert_SEQUENCE_at(self, index, value): self.SEQUENCE.insert(index, value)
    def replace_SEQUENCE_at(self, index, value): self.SEQUENCE[index] = value
    def hasContent_(self):
        if (
            self.ASSEMBLY is not None or
            self.SEQUENCE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceSequenceType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceSequenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceSequenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceSequenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceSequenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ASSEMBLY is not None:
            self.ASSEMBLY.export(outfile, level, namespace_, name_='ASSEMBLY', pretty_print=pretty_print)
        for SEQUENCE_ in self.SEQUENCE:
            SEQUENCE_.export(outfile, level, namespace_, name_='SEQUENCE', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceSequenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ASSEMBLY is not None:
            showIndent(outfile, level)
            outfile.write('ASSEMBLY=model_.ReferenceAssemblyType(\n')
            self.ASSEMBLY.exportLiteral(outfile, level, name_='ASSEMBLY')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SEQUENCE=[\n')
        level += 1
        for SEQUENCE_ in self.SEQUENCE:
            showIndent(outfile, level)
            outfile.write('model_.SEQUENCEType(\n')
            SEQUENCE_.exportLiteral(outfile, level, name_='SEQUENCEType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ASSEMBLY':
            obj_ = ReferenceAssemblyType.factory()
            obj_.build(child_)
            self.ASSEMBLY = obj_
            obj_.original_tagname_ = 'ASSEMBLY'
        elif nodeName_ == 'SEQUENCE':
            obj_ = SEQUENCEType.factory()
            obj_.build(child_)
            self.SEQUENCE.append(obj_)
            obj_.original_tagname_ = 'SEQUENCE'
# end class ReferenceSequenceType


class ProcessingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PIPELINE=None, DIRECTIVES=None):
        self.original_tagname_ = None
        self.PIPELINE = PIPELINE
        self.DIRECTIVES = DIRECTIVES
    def factory(*args_, **kwargs_):
        if ProcessingType.subclass:
            return ProcessingType.subclass(*args_, **kwargs_)
        else:
            return ProcessingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PIPELINE(self): return self.PIPELINE
    def set_PIPELINE(self, PIPELINE): self.PIPELINE = PIPELINE
    def get_DIRECTIVES(self): return self.DIRECTIVES
    def set_DIRECTIVES(self, DIRECTIVES): self.DIRECTIVES = DIRECTIVES
    def hasContent_(self):
        if (
            self.PIPELINE is not None or
            self.DIRECTIVES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProcessingType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProcessingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProcessingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProcessingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PIPELINE is not None:
            self.PIPELINE.export(outfile, level, namespace_, name_='PIPELINE', pretty_print=pretty_print)
        if self.DIRECTIVES is not None:
            self.DIRECTIVES.export(outfile, level, namespace_, name_='DIRECTIVES', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProcessingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PIPELINE is not None:
            showIndent(outfile, level)
            outfile.write('PIPELINE=model_.PipelineType(\n')
            self.PIPELINE.exportLiteral(outfile, level, name_='PIPELINE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DIRECTIVES is not None:
            showIndent(outfile, level)
            outfile.write('DIRECTIVES=model_.SequencingDirectivesType(\n')
            self.DIRECTIVES.exportLiteral(outfile, level, name_='DIRECTIVES')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PIPELINE':
            obj_ = PipelineType.factory()
            obj_.build(child_)
            self.PIPELINE = obj_
            obj_.original_tagname_ = 'PIPELINE'
        elif nodeName_ == 'DIRECTIVES':
            obj_ = SequencingDirectivesType.factory()
            obj_.build(child_)
            self.DIRECTIVES = obj_
            obj_.original_tagname_ = 'DIRECTIVES'
# end class ProcessingType


class EXPERIMENT_REFType(RefObjectType):
    subclass = None
    superclass = RefObjectType
    def __init__(self, accession=None, refname=None, refcenter=None, IDENTIFIERS=None):
        self.original_tagname_ = None
        super(EXPERIMENT_REFType, self).__init__(accession, refname, refcenter, IDENTIFIERS, )
    def factory(*args_, **kwargs_):
        if EXPERIMENT_REFType.subclass:
            return EXPERIMENT_REFType.subclass(*args_, **kwargs_)
        else:
            return EXPERIMENT_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(EXPERIMENT_REFType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EXPERIMENT_REFType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EXPERIMENT_REFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EXPERIMENT_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EXPERIMENT_REFType'):
        super(EXPERIMENT_REFType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='EXPERIMENT_REFType')
    def exportChildren(self, outfile, level, namespace_='', name_='EXPERIMENT_REFType', fromsubclass_=False, pretty_print=True):
        super(EXPERIMENT_REFType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EXPERIMENT_REFType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(EXPERIMENT_REFType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(EXPERIMENT_REFType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(EXPERIMENT_REFType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(EXPERIMENT_REFType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class EXPERIMENT_REFType


class RUN_TYPEType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, REFERENCE_ALIGNMENT=None):
        self.original_tagname_ = None
        self.REFERENCE_ALIGNMENT = REFERENCE_ALIGNMENT
    def factory(*args_, **kwargs_):
        if RUN_TYPEType.subclass:
            return RUN_TYPEType.subclass(*args_, **kwargs_)
        else:
            return RUN_TYPEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_REFERENCE_ALIGNMENT(self): return self.REFERENCE_ALIGNMENT
    def set_REFERENCE_ALIGNMENT(self, REFERENCE_ALIGNMENT): self.REFERENCE_ALIGNMENT = REFERENCE_ALIGNMENT
    def hasContent_(self):
        if (
            self.REFERENCE_ALIGNMENT is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RUN_TYPEType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RUN_TYPEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RUN_TYPEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RUN_TYPEType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RUN_TYPEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.REFERENCE_ALIGNMENT is not None:
            self.REFERENCE_ALIGNMENT.export(outfile, level, namespace_, name_='REFERENCE_ALIGNMENT', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RUN_TYPEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.REFERENCE_ALIGNMENT is not None:
            showIndent(outfile, level)
            outfile.write('REFERENCE_ALIGNMENT=model_.ReferenceSequenceType(\n')
            self.REFERENCE_ALIGNMENT.exportLiteral(outfile, level, name_='REFERENCE_ALIGNMENT')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'REFERENCE_ALIGNMENT':
            obj_ = ReferenceSequenceType.factory()
            obj_.build(child_)
            self.REFERENCE_ALIGNMENT = obj_
            obj_.original_tagname_ = 'REFERENCE_ALIGNMENT'
# end class RUN_TYPEType


class DATA_BLOCKType(GeneratedsSuper):
    """Allow for an individual DATA_BLOCK to be associated with a member of
    a sample pool."""
    subclass = None
    superclass = None
    def __init__(self, member_name=None, FILES=None):
        self.original_tagname_ = None
        self.member_name = _cast(None, member_name)
        self.FILES = FILES
    def factory(*args_, **kwargs_):
        if DATA_BLOCKType.subclass:
            return DATA_BLOCKType.subclass(*args_, **kwargs_)
        else:
            return DATA_BLOCKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FILES(self): return self.FILES
    def set_FILES(self, FILES): self.FILES = FILES
    def get_member_name(self): return self.member_name
    def set_member_name(self, member_name): self.member_name = member_name
    def hasContent_(self):
        if (
            self.FILES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='DATA_BLOCKType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='DATA_BLOCKType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='DATA_BLOCKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='DATA_BLOCKType'):
        if self.member_name is not None and 'member_name' not in already_processed:
            already_processed.add('member_name')
            outfile.write(' member_name=%s' % (self.gds_format_string(quote_attrib(self.member_name).encode(ExternalEncoding), input_name='member_name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='DATA_BLOCKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.FILES is not None:
            self.FILES.export(outfile, level, namespace_, name_='FILES', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='DATA_BLOCKType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.member_name is not None and 'member_name' not in already_processed:
            already_processed.add('member_name')
            showIndent(outfile, level)
            outfile.write('member_name="%s",\n' % (self.member_name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.FILES is not None:
            showIndent(outfile, level)
            outfile.write('FILES=model_.FILESType(\n')
            self.FILES.exportLiteral(outfile, level, name_='FILES')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('member_name', node)
        if value is not None and 'member_name' not in already_processed:
            already_processed.add('member_name')
            self.member_name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FILES':
            obj_ = FILESType.factory()
            obj_.build(child_)
            self.FILES = obj_
            obj_.original_tagname_ = 'FILES'
# end class DATA_BLOCKType


class FILESType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, FILE=None):
        self.original_tagname_ = None
        if FILE is None:
            self.FILE = []
        else:
            self.FILE = FILE
    def factory(*args_, **kwargs_):
        if FILESType.subclass:
            return FILESType.subclass(*args_, **kwargs_)
        else:
            return FILESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_FILE(self): return self.FILE
    def set_FILE(self, FILE): self.FILE = FILE
    def add_FILE(self, value): self.FILE.append(value)
    def insert_FILE_at(self, index, value): self.FILE.insert(index, value)
    def replace_FILE_at(self, index, value): self.FILE[index] = value
    def hasContent_(self):
        if (
            self.FILE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FILESType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FILESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FILESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FILESType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='FILESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for FILE_ in self.FILE:
            FILE_.export(outfile, level, namespace_, name_='FILE', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='FILESType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('FILE=[\n')
        level += 1
        for FILE_ in self.FILE:
            showIndent(outfile, level)
            outfile.write('model_.FILEType(\n')
            FILE_.exportLiteral(outfile, level, name_='FILEType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'FILE':
            obj_ = FILEType.factory()
            obj_.build(child_)
            self.FILE.append(obj_)
            obj_.original_tagname_ = 'FILE'
# end class FILESType


class FILEType(GeneratedsSuper):
    """The name or relative pathname of a run data file. The run data file
    model.Sequence Read Archives native format in serialized (single
    file) form.Standard Short Read Format file (.srf), all
    platforms454 Standard Flowgram Format file (.sff) Combined
    nucleotide/qualities sequence file in .fastq form. Please see
    SRA File Formats Guide for definitions of the definition and
    restrictions on this form. Please see SRA File Formats Guide for
    definitions of these file formats, and the SRA Submission
    Guidelines document for data series that are appropriate for
    your study. Sequence and qualities are minimally required. Tab
    delimited text file used to deliver certain auxiliary data along
    with sequencing submissions (only needed for certain use cases).
    The first line is devoted to column headers. Each column is
    dedicated to an INDSC data series type. Please see SRA File
    Formats Guide for definitions of the definition and restrictions
    on this form. A combination of 454 primary analysis output
    files, including seq qual Please see SRA File Formats Guide for
    definitions of these file formats, and the SRA Submission
    Guidelines document for data series that are appropriate for
    your study. Sequence and qualities are minimally required. 454
    base calls (for example .seq or .fna). Please see SRA File
    Formats Guide for definitions of these file formats, and the SRA
    Submission Guidelines document for data series that are
    appropriate for your study. Sequence and qualities are minimally
    required. 454 quality scores (for example .qual). Please see SRA
    File Formats Guide for definitions of these file formats, and
    the SRA Submission Guidelines document for data series that are
    appropriate for your study. Sequence and qualities are minimally
    required. A kind of fastq format specific to the Helicos
    platform. Please see SRA File Formats Guide for definitions of
    these file formats, and the SRA Submission Guidelines document
    for data series that are appropriate for your study. Sequence
    and qualities are minimally required. Please see SRA File
    Formats Guide for definitions of these file formats, and the SRA
    Submission Guidelines document for data series that are
    appropriate for your study. Sequence and qualities are minimally
    required. Please see SRA File Formats Guide for definitions of
    these file formats, and the SRA Submission Guidelines document
    for data series that are appropriate for your study. Sequence
    and qualities are minimally required. Please see SRA File
    Formats Guide for definitions of these file formats, and the SRA
    Submission Guidelines document for data series that are
    appropriate for your study. Sequence and qualities are minimally
    required. Please see SRA File Formats Guide for definitions of
    these file formats, and the SRA Submission Guidelines document
    for data series that are appropriate for your study. Sequence
    and qualities are minimally required. Please see SRA File
    Formats Guide for definitions of these file formats, and the SRA
    Submission Guidelines document for data series that are
    appropriate for your study. Sequence and qualities are minimally
    required. Please see SRA File Formats Guide for definitions of
    these file formats, and the SRA Submission Guidelines document
    for data series that are appropriate for your study. Sequence
    and qualities are minimally required. A combination of SOLiD
    primary analysis output files, including: csfasta _QV.qual
    _intensity.ScaledCY3.fasta _intensity.ScaledCY5.fasta
    _intensity.ScaledFTC.fasta _intensity.ScaledTXR.fasta Please see
    SRA File Formats Guide for definitions of these file formats,
    and the SRA Submission Guidelines document for data series that
    are appropriate for your study. Sequence and qualities are
    minimally required. Colorspace calls (for example .csfasta)
    Please see SRA File Formats Guide for definitions of these file
    formats, and the SRA Submission Guidelines document for data
    series that are appropriate for your study. Sequence and
    qualities are minimally required. Colorspace quality scores (for
    example .qual) Please see SRA File Formats Guide for definitions
    of these file formats, and the SRA Submission Guidelines
    document for data series that are appropriate for your study.
    Sequence and qualities are minimally required. Pacific
    Biosciences Hierarchical Data Format. Please see SRA File
    Formats Guide for definitions of these file formats. Binary SAM
    format that combines alignment and sequencing data. Please see
    SRA File Formats Guide for definitions of these file formats,
    and the SRA Submission Guidelines document for data series that
    are appropriate for your study. Sequence and qualities are
    minimally required. Binary CRAM format that combines alignment
    and sequencing data. Please see SRA File Formats Guide for
    definitions of these file formats, and the SRA Submission
    Guidelines document for data series that are appropriate for
    your study. Sequence and qualities are minimally required.
    Please see SRA File Formats Guide for definitions of these file
    formats, and the SRA Submission Guidelines document for data
    series that are appropriate for your study. Sequence and
    qualities are minimally required. Oxford Nanopore data format.
    How the input data are scored for quality. The quality score is
    expressed as a probability of error in log form: -10 log(1/p)
    where p is the probability of error, with value range 0..63, 0
    meaning no base call. The quality score is expressed as the
    ratio of error to non-error in log form: -10 log(p/(1-p)) where
    p is the probability of error, with value range -40..40. The SRA
    will convert these into phred scale during loadtime. Character
    used in representing the minimum quality value. Helps specify
    how to decode text rendering of quality data. ASCII character
    based encoding. Single decimal value per quality score. Single
    hexadecimal value per quality score. Character used in
    representing the minimum quality value. Helps specify how to
    decode text rendering of quality data. ASCII value 33. Typically
    used for range 0..63. ASCII value 64. Typically used for range
    0..60. Checksum method used. Checksum generated by the MD5
    method (md5sum in unix). Checksum generated by the SHA-256
    method . Checksum of uncompressed file. Checksum of unenrypted
    file(used in conjunction with checksum of encrypted file)."""
    subclass = None
    superclass = None
    def __init__(self, checksum_method=None, ascii_offset=None, quality_encoding=None, filetype=None, unencrypted_checksum=None, filename=None, quality_scoring_system=None, checksum=None, READ_LABEL=None):
        self.original_tagname_ = None
        self.checksum_method = _cast(None, checksum_method)
        self.ascii_offset = _cast(None, ascii_offset)
        self.quality_encoding = _cast(None, quality_encoding)
        self.filetype = _cast(None, filetype)
        self.unencrypted_checksum = _cast(None, unencrypted_checksum)
        self.filename = _cast(None, filename)
        self.quality_scoring_system = _cast(None, quality_scoring_system)
        self.checksum = _cast(None, checksum)
        if READ_LABEL is None:
            self.READ_LABEL = []
        else:
            self.READ_LABEL = READ_LABEL
    def factory(*args_, **kwargs_):
        if FILEType.subclass:
            return FILEType.subclass(*args_, **kwargs_)
        else:
            return FILEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_READ_LABEL(self): return self.READ_LABEL
    def set_READ_LABEL(self, READ_LABEL): self.READ_LABEL = READ_LABEL
    def add_READ_LABEL(self, value): self.READ_LABEL.append(value)
    def insert_READ_LABEL_at(self, index, value): self.READ_LABEL.insert(index, value)
    def replace_READ_LABEL_at(self, index, value): self.READ_LABEL[index] = value
    def get_checksum_method(self): return self.checksum_method
    def set_checksum_method(self, checksum_method): self.checksum_method = checksum_method
    def get_ascii_offset(self): return self.ascii_offset
    def set_ascii_offset(self, ascii_offset): self.ascii_offset = ascii_offset
    def get_quality_encoding(self): return self.quality_encoding
    def set_quality_encoding(self, quality_encoding): self.quality_encoding = quality_encoding
    def get_filetype(self): return self.filetype
    def set_filetype(self, filetype): self.filetype = filetype
    def get_unencrypted_checksum(self): return self.unencrypted_checksum
    def set_unencrypted_checksum(self, unencrypted_checksum): self.unencrypted_checksum = unencrypted_checksum
    def get_filename(self): return self.filename
    def set_filename(self, filename): self.filename = filename
    def get_quality_scoring_system(self): return self.quality_scoring_system
    def set_quality_scoring_system(self, quality_scoring_system): self.quality_scoring_system = quality_scoring_system
    def get_checksum(self): return self.checksum
    def set_checksum(self, checksum): self.checksum = checksum
    def hasContent_(self):
        if (
            self.READ_LABEL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='FILEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='FILEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='FILEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='FILEType'):
        if self.checksum_method is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            outfile.write(' checksum_method=%s' % (self.gds_format_string(quote_attrib(self.checksum_method).encode(ExternalEncoding), input_name='checksum_method'), ))
        if self.ascii_offset is not None and 'ascii_offset' not in already_processed:
            already_processed.add('ascii_offset')
            outfile.write(' ascii_offset=%s' % (self.gds_format_string(quote_attrib(self.ascii_offset).encode(ExternalEncoding), input_name='ascii_offset'), ))
        if self.quality_encoding is not None and 'quality_encoding' not in already_processed:
            already_processed.add('quality_encoding')
            outfile.write(' quality_encoding=%s' % (self.gds_format_string(quote_attrib(self.quality_encoding).encode(ExternalEncoding), input_name='quality_encoding'), ))
        if self.filetype is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            outfile.write(' filetype=%s' % (self.gds_format_string(quote_attrib(self.filetype).encode(ExternalEncoding), input_name='filetype'), ))
        if self.unencrypted_checksum is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            outfile.write(' unencrypted_checksum=%s' % (self.gds_format_string(quote_attrib(self.unencrypted_checksum).encode(ExternalEncoding), input_name='unencrypted_checksum'), ))
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            outfile.write(' filename=%s' % (self.gds_format_string(quote_attrib(self.filename).encode(ExternalEncoding), input_name='filename'), ))
        if self.quality_scoring_system is not None and 'quality_scoring_system' not in already_processed:
            already_processed.add('quality_scoring_system')
            outfile.write(' quality_scoring_system=%s' % (self.gds_format_string(quote_attrib(self.quality_scoring_system).encode(ExternalEncoding), input_name='quality_scoring_system'), ))
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            outfile.write(' checksum=%s' % (self.gds_format_string(quote_attrib(self.checksum).encode(ExternalEncoding), input_name='checksum'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='FILEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for READ_LABEL_ in self.READ_LABEL:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_LABEL>%s</%sREAD_LABEL>%s' % (namespace_, self.gds_format_string(quote_xml(READ_LABEL_).encode(ExternalEncoding), input_name='READ_LABEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='FILEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.checksum_method is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            showIndent(outfile, level)
            outfile.write('checksum_method="%s",\n' % (self.checksum_method,))
        if self.ascii_offset is not None and 'ascii_offset' not in already_processed:
            already_processed.add('ascii_offset')
            showIndent(outfile, level)
            outfile.write('ascii_offset="%s",\n' % (self.ascii_offset,))
        if self.quality_encoding is not None and 'quality_encoding' not in already_processed:
            already_processed.add('quality_encoding')
            showIndent(outfile, level)
            outfile.write('quality_encoding="%s",\n' % (self.quality_encoding,))
        if self.filetype is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            showIndent(outfile, level)
            outfile.write('filetype="%s",\n' % (self.filetype,))
        if self.unencrypted_checksum is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            showIndent(outfile, level)
            outfile.write('unencrypted_checksum="%s",\n' % (self.unencrypted_checksum,))
        if self.filename is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            showIndent(outfile, level)
            outfile.write('filename="%s",\n' % (self.filename,))
        if self.quality_scoring_system is not None and 'quality_scoring_system' not in already_processed:
            already_processed.add('quality_scoring_system')
            showIndent(outfile, level)
            outfile.write('quality_scoring_system="%s",\n' % (self.quality_scoring_system,))
        if self.checksum is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            showIndent(outfile, level)
            outfile.write('checksum="%s",\n' % (self.checksum,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('READ_LABEL=[\n')
        level += 1
        for READ_LABEL_ in self.READ_LABEL:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(READ_LABEL_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('checksum_method', node)
        if value is not None and 'checksum_method' not in already_processed:
            already_processed.add('checksum_method')
            self.checksum_method = value
        value = find_attr_value_('ascii_offset', node)
        if value is not None and 'ascii_offset' not in already_processed:
            already_processed.add('ascii_offset')
            self.ascii_offset = value
        value = find_attr_value_('quality_encoding', node)
        if value is not None and 'quality_encoding' not in already_processed:
            already_processed.add('quality_encoding')
            self.quality_encoding = value
        value = find_attr_value_('filetype', node)
        if value is not None and 'filetype' not in already_processed:
            already_processed.add('filetype')
            self.filetype = value
        value = find_attr_value_('unencrypted_checksum', node)
        if value is not None and 'unencrypted_checksum' not in already_processed:
            already_processed.add('unencrypted_checksum')
            self.unencrypted_checksum = value
        value = find_attr_value_('filename', node)
        if value is not None and 'filename' not in already_processed:
            already_processed.add('filename')
            self.filename = value
        value = find_attr_value_('quality_scoring_system', node)
        if value is not None and 'quality_scoring_system' not in already_processed:
            already_processed.add('quality_scoring_system')
            self.quality_scoring_system = value
        value = find_attr_value_('checksum', node)
        if value is not None and 'checksum' not in already_processed:
            already_processed.add('checksum')
            self.checksum = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'READ_LABEL':
            READ_LABEL_ = child_.text
            READ_LABEL_ = self.gds_validate_string(READ_LABEL_, node, 'READ_LABEL')
            self.READ_LABEL.append(READ_LABEL_)
# end class FILEType


class RUN_LINKSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RUN_LINK=None):
        self.original_tagname_ = None
        if RUN_LINK is None:
            self.RUN_LINK = []
        else:
            self.RUN_LINK = RUN_LINK
    def factory(*args_, **kwargs_):
        if RUN_LINKSType.subclass:
            return RUN_LINKSType.subclass(*args_, **kwargs_)
        else:
            return RUN_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RUN_LINK(self): return self.RUN_LINK
    def set_RUN_LINK(self, RUN_LINK): self.RUN_LINK = RUN_LINK
    def add_RUN_LINK(self, value): self.RUN_LINK.append(value)
    def insert_RUN_LINK_at(self, index, value): self.RUN_LINK.insert(index, value)
    def replace_RUN_LINK_at(self, index, value): self.RUN_LINK[index] = value
    def hasContent_(self):
        if (
            self.RUN_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RUN_LINKSType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RUN_LINKSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RUN_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RUN_LINKSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RUN_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RUN_LINK_ in self.RUN_LINK:
            RUN_LINK_.export(outfile, level, namespace_, name_='RUN_LINK', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RUN_LINKSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RUN_LINK=[\n')
        level += 1
        for RUN_LINK_ in self.RUN_LINK:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            RUN_LINK_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RUN_LINK':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.RUN_LINK.append(obj_)
            obj_.original_tagname_ = 'RUN_LINK'
# end class RUN_LINKSType


class RUN_ATTRIBUTESType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, RUN_ATTRIBUTE=None):
        self.original_tagname_ = None
        if RUN_ATTRIBUTE is None:
            self.RUN_ATTRIBUTE = []
        else:
            self.RUN_ATTRIBUTE = RUN_ATTRIBUTE
    def factory(*args_, **kwargs_):
        if RUN_ATTRIBUTESType.subclass:
            return RUN_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return RUN_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_RUN_ATTRIBUTE(self): return self.RUN_ATTRIBUTE
    def set_RUN_ATTRIBUTE(self, RUN_ATTRIBUTE): self.RUN_ATTRIBUTE = RUN_ATTRIBUTE
    def add_RUN_ATTRIBUTE(self, value): self.RUN_ATTRIBUTE.append(value)
    def insert_RUN_ATTRIBUTE_at(self, index, value): self.RUN_ATTRIBUTE.insert(index, value)
    def replace_RUN_ATTRIBUTE_at(self, index, value): self.RUN_ATTRIBUTE[index] = value
    def hasContent_(self):
        if (
            self.RUN_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RUN_ATTRIBUTESType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RUN_ATTRIBUTESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RUN_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RUN_ATTRIBUTESType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='RUN_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for RUN_ATTRIBUTE_ in self.RUN_ATTRIBUTE:
            RUN_ATTRIBUTE_.export(outfile, level, namespace_, name_='RUN_ATTRIBUTE', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RUN_ATTRIBUTESType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('RUN_ATTRIBUTE=[\n')
        level += 1
        for RUN_ATTRIBUTE_ in self.RUN_ATTRIBUTE:
            showIndent(outfile, level)
            outfile.write('model_.AttributeType(\n')
            RUN_ATTRIBUTE_.exportLiteral(outfile, level, name_='AttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'RUN_ATTRIBUTE':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.RUN_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'RUN_ATTRIBUTE'
# end class RUN_ATTRIBUTESType


class URL_LINKType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL
    def factory(*args_, **kwargs_):
        if URL_LINKType.subclass:
            return URL_LINKType.subclass(*args_, **kwargs_)
        else:
            return URL_LINKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def hasContent_(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='URL_LINKType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL_LINKType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URL_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL_LINKType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URL_LINKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='URL_LINKType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LABEL is not None:
            showIndent(outfile, level)
            outfile.write('LABEL=%s,\n' % quote_python(self.LABEL).encode(ExternalEncoding))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URL_LINKType


class ENTREZ_LINKType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DB=None, ID=None, QUERY=None, LABEL=None):
        self.original_tagname_ = None
        self.DB = DB
        self.ID = ID
        self.QUERY = QUERY
        self.LABEL = LABEL
    def factory(*args_, **kwargs_):
        if ENTREZ_LINKType.subclass:
            return ENTREZ_LINKType.subclass(*args_, **kwargs_)
        else:
            return ENTREZ_LINKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DB(self): return self.DB
    def set_DB(self, DB): self.DB = DB
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_QUERY(self): return self.QUERY
    def set_QUERY(self, QUERY): self.QUERY = QUERY
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def hasContent_(self):
        if (
            self.DB is not None or
            self.ID is not None or
            self.QUERY is not None or
            self.LABEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ENTREZ_LINKType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ENTREZ_LINKType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ENTREZ_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ENTREZ_LINKType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ENTREZ_LINKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB>%s</%sDB>%s' % (namespace_, self.gds_format_string(quote_xml(self.DB).encode(ExternalEncoding), input_name='DB'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_integer(self.ID, input_name='ID'), namespace_, eol_))
        if self.QUERY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQUERY>%s</%sQUERY>%s' % (namespace_, self.gds_format_string(quote_xml(self.QUERY).encode(ExternalEncoding), input_name='QUERY'), namespace_, eol_))
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ENTREZ_LINKType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DB is not None:
            showIndent(outfile, level)
            outfile.write('DB=%s,\n' % quote_python(self.DB).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % self.ID)
        if self.QUERY is not None:
            showIndent(outfile, level)
            outfile.write('QUERY=%s,\n' % quote_python(self.QUERY).encode(ExternalEncoding))
        if self.LABEL is not None:
            showIndent(outfile, level)
            outfile.write('LABEL=%s,\n' % quote_python(self.LABEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DB':
            DB_ = child_.text
            DB_ = self.gds_validate_string(DB_, node, 'DB')
            self.DB = DB_
        elif nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'QUERY':
            QUERY_ = child_.text
            QUERY_ = self.gds_validate_string(QUERY_, node, 'QUERY')
            self.QUERY = QUERY_
        elif nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
# end class ENTREZ_LINKType


class SPOT_DECODE_SPECType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SPOT_LENGTH=None, READ_SPEC=None):
        self.original_tagname_ = None
        self.SPOT_LENGTH = SPOT_LENGTH
        if READ_SPEC is None:
            self.READ_SPEC = []
        else:
            self.READ_SPEC = READ_SPEC
    def factory(*args_, **kwargs_):
        if SPOT_DECODE_SPECType.subclass:
            return SPOT_DECODE_SPECType.subclass(*args_, **kwargs_)
        else:
            return SPOT_DECODE_SPECType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SPOT_LENGTH(self): return self.SPOT_LENGTH
    def set_SPOT_LENGTH(self, SPOT_LENGTH): self.SPOT_LENGTH = SPOT_LENGTH
    def get_READ_SPEC(self): return self.READ_SPEC
    def set_READ_SPEC(self, READ_SPEC): self.READ_SPEC = READ_SPEC
    def add_READ_SPEC(self, value): self.READ_SPEC.append(value)
    def insert_READ_SPEC_at(self, index, value): self.READ_SPEC.insert(index, value)
    def replace_READ_SPEC_at(self, index, value): self.READ_SPEC[index] = value
    def hasContent_(self):
        if (
            self.SPOT_LENGTH is not None or
            self.READ_SPEC
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SPOT_DECODE_SPECType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SPOT_DECODE_SPECType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SPOT_DECODE_SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SPOT_DECODE_SPECType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SPOT_DECODE_SPECType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SPOT_LENGTH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSPOT_LENGTH>%s</%sSPOT_LENGTH>%s' % (namespace_, self.gds_format_integer(self.SPOT_LENGTH, input_name='SPOT_LENGTH'), namespace_, eol_))
        for READ_SPEC_ in self.READ_SPEC:
            READ_SPEC_.export(outfile, level, namespace_, name_='READ_SPEC', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SPOT_DECODE_SPECType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SPOT_LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('SPOT_LENGTH=%d,\n' % self.SPOT_LENGTH)
        showIndent(outfile, level)
        outfile.write('READ_SPEC=[\n')
        level += 1
        for READ_SPEC_ in self.READ_SPEC:
            showIndent(outfile, level)
            outfile.write('model_.READ_SPECType(\n')
            READ_SPEC_.exportLiteral(outfile, level, name_='READ_SPECType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SPOT_LENGTH':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SPOT_LENGTH')
            self.SPOT_LENGTH = ival_
        elif nodeName_ == 'READ_SPEC':
            obj_ = READ_SPECType.factory()
            obj_.build(child_)
            self.READ_SPEC.append(obj_)
            obj_.original_tagname_ = 'READ_SPEC'
# end class SPOT_DECODE_SPECType


class READ_SPECType(GeneratedsSuper):
    """There are various methods to ordering the reads on the spot."""
    subclass = None
    superclass = None
    def __init__(self, READ_INDEX=None, READ_LABEL=None, READ_CLASS=None, READ_TYPE='Forward', RELATIVE_ORDER=None, BASE_COORD=None, EXPECTED_BASECALL_TABLE=None):
        self.original_tagname_ = None
        self.READ_INDEX = READ_INDEX
        self.READ_LABEL = READ_LABEL
        self.READ_CLASS = READ_CLASS
        self.validate_READ_CLASSType(self.READ_CLASS)
        self.READ_TYPE = READ_TYPE
        self.validate_READ_TYPEType(self.READ_TYPE)
        self.RELATIVE_ORDER = RELATIVE_ORDER
        self.BASE_COORD = BASE_COORD
        self.EXPECTED_BASECALL_TABLE = EXPECTED_BASECALL_TABLE
    def factory(*args_, **kwargs_):
        if READ_SPECType.subclass:
            return READ_SPECType.subclass(*args_, **kwargs_)
        else:
            return READ_SPECType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_READ_INDEX(self): return self.READ_INDEX
    def set_READ_INDEX(self, READ_INDEX): self.READ_INDEX = READ_INDEX
    def get_READ_LABEL(self): return self.READ_LABEL
    def set_READ_LABEL(self, READ_LABEL): self.READ_LABEL = READ_LABEL
    def get_READ_CLASS(self): return self.READ_CLASS
    def set_READ_CLASS(self, READ_CLASS): self.READ_CLASS = READ_CLASS
    def get_READ_TYPE(self): return self.READ_TYPE
    def set_READ_TYPE(self, READ_TYPE): self.READ_TYPE = READ_TYPE
    def get_RELATIVE_ORDER(self): return self.RELATIVE_ORDER
    def set_RELATIVE_ORDER(self, RELATIVE_ORDER): self.RELATIVE_ORDER = RELATIVE_ORDER
    def get_BASE_COORD(self): return self.BASE_COORD
    def set_BASE_COORD(self, BASE_COORD): self.BASE_COORD = BASE_COORD
    def get_EXPECTED_BASECALL_TABLE(self): return self.EXPECTED_BASECALL_TABLE
    def set_EXPECTED_BASECALL_TABLE(self, EXPECTED_BASECALL_TABLE): self.EXPECTED_BASECALL_TABLE = EXPECTED_BASECALL_TABLE
    def validate_READ_CLASSType(self, value):
        # Validate type READ_CLASSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Application Read', 'Technical Read']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on READ_CLASSType' % {"value" : value.encode("utf-8")} )
    def validate_READ_TYPEType(self, value):
        # Validate type READ_TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Forward', 'Reverse', 'Adapter', 'Primer', 'Linker', 'BarCode', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on READ_TYPEType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.READ_INDEX is not None or
            self.READ_LABEL is not None or
            self.READ_CLASS is not None or
            self.READ_TYPE != "Forward" or
            self.RELATIVE_ORDER is not None or
            self.BASE_COORD is not None or
            self.EXPECTED_BASECALL_TABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='READ_SPECType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='READ_SPECType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='READ_SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='READ_SPECType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='READ_SPECType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.READ_INDEX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_INDEX>%s</%sREAD_INDEX>%s' % (namespace_, self.gds_format_integer(self.READ_INDEX, input_name='READ_INDEX'), namespace_, eol_))
        if self.READ_LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_LABEL>%s</%sREAD_LABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.READ_LABEL).encode(ExternalEncoding), input_name='READ_LABEL'), namespace_, eol_))
        if self.READ_CLASS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_CLASS>%s</%sREAD_CLASS>%s' % (namespace_, self.gds_format_string(quote_xml(self.READ_CLASS).encode(ExternalEncoding), input_name='READ_CLASS'), namespace_, eol_))
        if self.READ_TYPE != "Forward":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_TYPE>%s</%sREAD_TYPE>%s' % (namespace_, self.gds_format_string(quote_xml(self.READ_TYPE).encode(ExternalEncoding), input_name='READ_TYPE'), namespace_, eol_))
        if self.RELATIVE_ORDER is not None:
            self.RELATIVE_ORDER.export(outfile, level, namespace_, name_='RELATIVE_ORDER', pretty_print=pretty_print)
        if self.BASE_COORD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBASE_COORD>%s</%sBASE_COORD>%s' % (namespace_, self.gds_format_integer(self.BASE_COORD, input_name='BASE_COORD'), namespace_, eol_))
        if self.EXPECTED_BASECALL_TABLE is not None:
            self.EXPECTED_BASECALL_TABLE.export(outfile, level, namespace_, name_='EXPECTED_BASECALL_TABLE', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='READ_SPECType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.READ_INDEX is not None:
            showIndent(outfile, level)
            outfile.write('READ_INDEX=%d,\n' % self.READ_INDEX)
        if self.READ_LABEL is not None:
            showIndent(outfile, level)
            outfile.write('READ_LABEL=%s,\n' % quote_python(self.READ_LABEL).encode(ExternalEncoding))
        if self.READ_CLASS is not None:
            showIndent(outfile, level)
            outfile.write('READ_CLASS=%s,\n' % quote_python(self.READ_CLASS).encode(ExternalEncoding))
        if self.READ_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('READ_TYPE=%s,\n' % quote_python(self.READ_TYPE).encode(ExternalEncoding))
        if self.RELATIVE_ORDER is not None:
            showIndent(outfile, level)
            outfile.write('RELATIVE_ORDER=model_.RELATIVE_ORDERType(\n')
            self.RELATIVE_ORDER.exportLiteral(outfile, level, name_='RELATIVE_ORDER')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BASE_COORD is not None:
            showIndent(outfile, level)
            outfile.write('BASE_COORD=%d,\n' % self.BASE_COORD)
        if self.EXPECTED_BASECALL_TABLE is not None:
            showIndent(outfile, level)
            outfile.write('EXPECTED_BASECALL_TABLE=model_.EXPECTED_BASECALL_TABLEType(\n')
            self.EXPECTED_BASECALL_TABLE.exportLiteral(outfile, level, name_='EXPECTED_BASECALL_TABLE')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'READ_INDEX':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'READ_INDEX')
            self.READ_INDEX = ival_
        elif nodeName_ == 'READ_LABEL':
            READ_LABEL_ = child_.text
            READ_LABEL_ = self.gds_validate_string(READ_LABEL_, node, 'READ_LABEL')
            self.READ_LABEL = READ_LABEL_
        elif nodeName_ == 'READ_CLASS':
            READ_CLASS_ = child_.text
            READ_CLASS_ = self.gds_validate_string(READ_CLASS_, node, 'READ_CLASS')
            self.READ_CLASS = READ_CLASS_
            # validate type READ_CLASSType
            self.validate_READ_CLASSType(self.READ_CLASS)
        elif nodeName_ == 'READ_TYPE':
            READ_TYPE_ = child_.text
            READ_TYPE_ = self.gds_validate_string(READ_TYPE_, node, 'READ_TYPE')
            self.READ_TYPE = READ_TYPE_
            # validate type READ_TYPEType
            self.validate_READ_TYPEType(self.READ_TYPE)
        elif nodeName_ == 'RELATIVE_ORDER':
            obj_ = RELATIVE_ORDERType.factory()
            obj_.build(child_)
            self.RELATIVE_ORDER = obj_
            obj_.original_tagname_ = 'RELATIVE_ORDER'
        elif nodeName_ == 'BASE_COORD':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BASE_COORD')
            self.BASE_COORD = ival_
        elif nodeName_ == 'EXPECTED_BASECALL_TABLE':
            obj_ = EXPECTED_BASECALL_TABLEType.factory()
            obj_.build(child_)
            self.EXPECTED_BASECALL_TABLE = obj_
            obj_.original_tagname_ = 'EXPECTED_BASECALL_TABLE'
# end class READ_SPECType


class RELATIVE_ORDERType(GeneratedsSuper):
    """Specify the read index that precedes this read. Specify the read
    index that follows this read."""
    subclass = None
    superclass = None
    def __init__(self, follows_read_index=None, precedes_read_index=None):
        self.original_tagname_ = None
        self.follows_read_index = _cast(int, follows_read_index)
        self.precedes_read_index = _cast(int, precedes_read_index)
    def factory(*args_, **kwargs_):
        if RELATIVE_ORDERType.subclass:
            return RELATIVE_ORDERType.subclass(*args_, **kwargs_)
        else:
            return RELATIVE_ORDERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_follows_read_index(self): return self.follows_read_index
    def set_follows_read_index(self, follows_read_index): self.follows_read_index = follows_read_index
    def get_precedes_read_index(self): return self.precedes_read_index
    def set_precedes_read_index(self, precedes_read_index): self.precedes_read_index = precedes_read_index
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RELATIVE_ORDERType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RELATIVE_ORDERType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RELATIVE_ORDERType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RELATIVE_ORDERType'):
        if self.follows_read_index is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            outfile.write(' follows_read_index="%s"' % self.gds_format_integer(self.follows_read_index, input_name='follows_read_index'))
        if self.precedes_read_index is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            outfile.write(' precedes_read_index="%s"' % self.gds_format_integer(self.precedes_read_index, input_name='precedes_read_index'))
    def exportChildren(self, outfile, level, namespace_='', name_='RELATIVE_ORDERType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='RELATIVE_ORDERType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.follows_read_index is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            showIndent(outfile, level)
            outfile.write('follows_read_index=%d,\n' % (self.follows_read_index,))
        if self.precedes_read_index is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            showIndent(outfile, level)
            outfile.write('precedes_read_index=%d,\n' % (self.precedes_read_index,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('follows_read_index', node)
        if value is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            try:
                self.follows_read_index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.follows_read_index < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('precedes_read_index', node)
        if value is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            try:
                self.precedes_read_index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.precedes_read_index < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RELATIVE_ORDERType


class EXPECTED_BASECALL_TABLEType(GeneratedsSuper):
    """Specify whether the spot should have a default length for this tag
    if the expected base cannot be matched. Specify an optional
    starting point for tag (base offset from 1)."""
    subclass = None
    superclass = None
    def __init__(self, default_length=None, base_coord=None, BASECALL=None):
        self.original_tagname_ = None
        self.default_length = _cast(int, default_length)
        self.base_coord = _cast(int, base_coord)
        if BASECALL is None:
            self.BASECALL = []
        else:
            self.BASECALL = BASECALL
    def factory(*args_, **kwargs_):
        if EXPECTED_BASECALL_TABLEType.subclass:
            return EXPECTED_BASECALL_TABLEType.subclass(*args_, **kwargs_)
        else:
            return EXPECTED_BASECALL_TABLEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BASECALL(self): return self.BASECALL
    def set_BASECALL(self, BASECALL): self.BASECALL = BASECALL
    def add_BASECALL(self, value): self.BASECALL.append(value)
    def insert_BASECALL_at(self, index, value): self.BASECALL.insert(index, value)
    def replace_BASECALL_at(self, index, value): self.BASECALL[index] = value
    def get_default_length(self): return self.default_length
    def set_default_length(self, default_length): self.default_length = default_length
    def get_base_coord(self): return self.base_coord
    def set_base_coord(self, base_coord): self.base_coord = base_coord
    def hasContent_(self):
        if (
            self.BASECALL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EXPECTED_BASECALL_TABLEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EXPECTED_BASECALL_TABLEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EXPECTED_BASECALL_TABLEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EXPECTED_BASECALL_TABLEType'):
        if self.default_length is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            outfile.write(' default_length="%s"' % self.gds_format_integer(self.default_length, input_name='default_length'))
        if self.base_coord is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            outfile.write(' base_coord="%s"' % self.gds_format_integer(self.base_coord, input_name='base_coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='EXPECTED_BASECALL_TABLEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BASECALL_ in self.BASECALL:
            BASECALL_.export(outfile, level, namespace_, name_='BASECALL', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EXPECTED_BASECALL_TABLEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default_length is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            showIndent(outfile, level)
            outfile.write('default_length=%d,\n' % (self.default_length,))
        if self.base_coord is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            showIndent(outfile, level)
            outfile.write('base_coord=%d,\n' % (self.base_coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('BASECALL=[\n')
        level += 1
        for BASECALL_ in self.BASECALL:
            showIndent(outfile, level)
            outfile.write('model_.BASECALLType(\n')
            BASECALL_.exportLiteral(outfile, level, name_='BASECALLType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_length', node)
        if value is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            try:
                self.default_length = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.default_length < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('base_coord', node)
        if value is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            try:
                self.base_coord = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.base_coord < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BASECALL':
            obj_ = BASECALLType.factory()
            obj_.build(child_)
            self.BASECALL.append(obj_)
            obj_.original_tagname_ = 'BASECALL'
# end class EXPECTED_BASECALL_TABLEType


class BASECALLType(GeneratedsSuper):
    """When match occurs, the read will be tagged with this group
    membership Minimum number of matches to trigger identification.
    Maximum number of mismatches Where the match should occur.
    Changes the rules on how min_match and max_mismatch are counted.
    Only @max_mismatch influences matching process Both matches and
    mismatches are counted. When @max_mismatch is exceeded - it is
    not a match. When @min_match is reached - match is declared.
    Both matches and mismatches are counted. When @max_mismatch is
    exceeded - it is not a match. When @min_match is reached - match
    is declared."""
    subclass = None
    superclass = None
    def __init__(self, max_mismatch=None, min_match=None, match_edge=None, read_group_tag=None, valueOf_=None):
        self.original_tagname_ = None
        self.max_mismatch = _cast(int, max_mismatch)
        self.min_match = _cast(int, min_match)
        self.match_edge = _cast(None, match_edge)
        self.read_group_tag = _cast(None, read_group_tag)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if BASECALLType.subclass:
            return BASECALLType.subclass(*args_, **kwargs_)
        else:
            return BASECALLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max_mismatch(self): return self.max_mismatch
    def set_max_mismatch(self, max_mismatch): self.max_mismatch = max_mismatch
    def get_min_match(self): return self.min_match
    def set_min_match(self, min_match): self.min_match = min_match
    def get_match_edge(self): return self.match_edge
    def set_match_edge(self, match_edge): self.match_edge = match_edge
    def get_read_group_tag(self): return self.read_group_tag
    def set_read_group_tag(self, read_group_tag): self.read_group_tag = read_group_tag
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BASECALLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BASECALLType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BASECALLType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BASECALLType'):
        if self.max_mismatch is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            outfile.write(' max_mismatch="%s"' % self.gds_format_integer(self.max_mismatch, input_name='max_mismatch'))
        if self.min_match is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            outfile.write(' min_match="%s"' % self.gds_format_integer(self.min_match, input_name='min_match'))
        if self.match_edge is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            outfile.write(' match_edge=%s' % (self.gds_format_string(quote_attrib(self.match_edge).encode(ExternalEncoding), input_name='match_edge'), ))
        if self.read_group_tag is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            outfile.write(' read_group_tag=%s' % (self.gds_format_string(quote_attrib(self.read_group_tag).encode(ExternalEncoding), input_name='read_group_tag'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BASECALLType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BASECALLType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.max_mismatch is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            showIndent(outfile, level)
            outfile.write('max_mismatch=%d,\n' % (self.max_mismatch,))
        if self.min_match is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            showIndent(outfile, level)
            outfile.write('min_match=%d,\n' % (self.min_match,))
        if self.match_edge is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            showIndent(outfile, level)
            outfile.write('match_edge="%s",\n' % (self.match_edge,))
        if self.read_group_tag is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            showIndent(outfile, level)
            outfile.write('read_group_tag="%s",\n' % (self.read_group_tag,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max_mismatch', node)
        if value is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            try:
                self.max_mismatch = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.max_mismatch < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('min_match', node)
        if value is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            try:
                self.min_match = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.min_match < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('match_edge', node)
        if value is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            self.match_edge = value
        value = find_attr_value_('read_group_tag', node)
        if value is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            self.read_group_tag = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BASECALLType


class LS454Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_type454Model(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if LS454Type.subclass:
            return LS454Type.subclass(*args_, **kwargs_)
        else:
            return LS454Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_type454Model(self, value):
        # Validate type type454Model, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['454 GS', '454 GS 20', '454 GS FLX', '454 GS FLX+', '454 GS FLX Titanium', '454 GS Junior', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on type454Model' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LS454Type', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LS454Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LS454Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LS454Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LS454Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LS454Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type type454Model
            self.validate_type454Model(self.INSTRUMENT_MODEL)
# end class LS454Type


class ILLUMINAType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeIlluminaModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if ILLUMINAType.subclass:
            return ILLUMINAType.subclass(*args_, **kwargs_)
        else:
            return ILLUMINAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeIlluminaModel(self, value):
        # Validate type typeIlluminaModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Illumina Genome Analyzer', 'Illumina Genome Analyzer II', 'Illumina Genome Analyzer IIx', 'Illumina HiSeq 2500', 'Illumina HiSeq 2000', 'Illumina HiSeq 1500', 'Illumina HiSeq 1000', 'Illumina MiSeq', 'Illumina HiScanSQ', 'HiSeq X Ten', 'NextSeq 500', 'HiSeq X Five', 'Illumina HiSeq 3000', 'Illumina HiSeq 4000', 'NextSeq 550', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeIlluminaModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ILLUMINAType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ILLUMINAType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ILLUMINAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ILLUMINAType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ILLUMINAType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ILLUMINAType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeIlluminaModel
            self.validate_typeIlluminaModel(self.INSTRUMENT_MODEL)
# end class ILLUMINAType


class HELICOSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeHelicosModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if HELICOSType.subclass:
            return HELICOSType.subclass(*args_, **kwargs_)
        else:
            return HELICOSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeHelicosModel(self, value):
        # Validate type typeHelicosModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Helicos HeliScope', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeHelicosModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HELICOSType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HELICOSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HELICOSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HELICOSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HELICOSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='HELICOSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeHelicosModel
            self.validate_typeHelicosModel(self.INSTRUMENT_MODEL)
# end class HELICOSType


class ABI_SOLIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeAbiSolidModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if ABI_SOLIDType.subclass:
            return ABI_SOLIDType.subclass(*args_, **kwargs_)
        else:
            return ABI_SOLIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeAbiSolidModel(self, value):
        # Validate type typeAbiSolidModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AB SOLiD System', 'AB SOLiD System 2.0', 'AB SOLiD System 3.0', 'AB SOLiD 3 Plus System', 'AB SOLiD 4 System', 'AB SOLiD 4hq System', 'AB SOLiD PI System', 'AB 5500 Genetic Analyzer', 'AB 5500xl Genetic Analyzer', 'AB 5500xl-W Genetic Analysis System', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeAbiSolidModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ABI_SOLIDType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ABI_SOLIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ABI_SOLIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ABI_SOLIDType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ABI_SOLIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ABI_SOLIDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeAbiSolidModel
            self.validate_typeAbiSolidModel(self.INSTRUMENT_MODEL)
# end class ABI_SOLIDType


class COMPLETE_GENOMICSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeCGModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if COMPLETE_GENOMICSType.subclass:
            return COMPLETE_GENOMICSType.subclass(*args_, **kwargs_)
        else:
            return COMPLETE_GENOMICSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeCGModel(self, value):
        # Validate type typeCGModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Complete Genomics', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeCGModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COMPLETE_GENOMICSType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMPLETE_GENOMICSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMPLETE_GENOMICSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMPLETE_GENOMICSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='COMPLETE_GENOMICSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='COMPLETE_GENOMICSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeCGModel
            self.validate_typeCGModel(self.INSTRUMENT_MODEL)
# end class COMPLETE_GENOMICSType


class BGISEQType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeBGISEQModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if BGISEQType.subclass:
            return BGISEQType.subclass(*args_, **kwargs_)
        else:
            return BGISEQType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeBGISEQModel(self, value):
        # Validate type typeBGISEQModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BGISEQ-500']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeBGISEQModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BGISEQType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BGISEQType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BGISEQType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BGISEQType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BGISEQType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='BGISEQType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeBGISEQModel
            self.validate_typeBGISEQModel(self.INSTRUMENT_MODEL)
# end class BGISEQType


class OXFORD_NANOPOREType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeOxfordNanoporeModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if OXFORD_NANOPOREType.subclass:
            return OXFORD_NANOPOREType.subclass(*args_, **kwargs_)
        else:
            return OXFORD_NANOPOREType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeOxfordNanoporeModel(self, value):
        # Validate type typeOxfordNanoporeModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MinION', 'GridION', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeOxfordNanoporeModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OXFORD_NANOPOREType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OXFORD_NANOPOREType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OXFORD_NANOPOREType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OXFORD_NANOPOREType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OXFORD_NANOPOREType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OXFORD_NANOPOREType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeOxfordNanoporeModel
            self.validate_typeOxfordNanoporeModel(self.INSTRUMENT_MODEL)
# end class OXFORD_NANOPOREType


class PACBIO_SMRTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typePacBioModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if PACBIO_SMRTType.subclass:
            return PACBIO_SMRTType.subclass(*args_, **kwargs_)
        else:
            return PACBIO_SMRTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typePacBioModel(self, value):
        # Validate type typePacBioModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PacBio RS', 'PacBio RS II', 'Sequel', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typePacBioModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PACBIO_SMRTType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PACBIO_SMRTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PACBIO_SMRTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PACBIO_SMRTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PACBIO_SMRTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PACBIO_SMRTType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typePacBioModel
            self.validate_typePacBioModel(self.INSTRUMENT_MODEL)
# end class PACBIO_SMRTType


class ION_TORRENTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeIontorrentModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if ION_TORRENTType.subclass:
            return ION_TORRENTType.subclass(*args_, **kwargs_)
        else:
            return ION_TORRENTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeIontorrentModel(self, value):
        # Validate type typeIontorrentModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Ion Torrent PGM', 'Ion Torrent Proton', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeIontorrentModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ION_TORRENTType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ION_TORRENTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ION_TORRENTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ION_TORRENTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ION_TORRENTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ION_TORRENTType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeIontorrentModel
            self.validate_typeIontorrentModel(self.INSTRUMENT_MODEL)
# end class ION_TORRENTType


class CAPILLARYType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeCapillaryModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if CAPILLARYType.subclass:
            return CAPILLARYType.subclass(*args_, **kwargs_)
        else:
            return CAPILLARYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeCapillaryModel(self, value):
        # Validate type typeCapillaryModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AB 3730xL Genetic Analyzer', 'AB 3730 Genetic Analyzer', 'AB 3500xL Genetic Analyzer', 'AB 3500 Genetic Analyzer', 'AB 3130xL Genetic Analyzer', 'AB 3130 Genetic Analyzer', 'AB 310 Genetic Analyzer', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeCapillaryModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CAPILLARYType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CAPILLARYType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CAPILLARYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CAPILLARYType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CAPILLARYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CAPILLARYType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeCapillaryModel
            self.validate_typeCapillaryModel(self.INSTRUMENT_MODEL)
# end class CAPILLARYType


class PIPE_SECTIONType(GeneratedsSuper):
    """Name of the processing pipeline section."""
    subclass = None
    superclass = None
    def __init__(self, section_name=None, STEP_INDEX=None, PREV_STEP_INDEX=None, PROGRAM=None, VERSION=None, NOTES=None):
        self.original_tagname_ = None
        self.section_name = _cast(None, section_name)
        self.STEP_INDEX = STEP_INDEX
        if PREV_STEP_INDEX is None:
            self.PREV_STEP_INDEX = []
        else:
            self.PREV_STEP_INDEX = PREV_STEP_INDEX
        self.PROGRAM = PROGRAM
        self.VERSION = VERSION
        self.NOTES = NOTES
    def factory(*args_, **kwargs_):
        if PIPE_SECTIONType.subclass:
            return PIPE_SECTIONType.subclass(*args_, **kwargs_)
        else:
            return PIPE_SECTIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STEP_INDEX(self): return self.STEP_INDEX
    def set_STEP_INDEX(self, STEP_INDEX): self.STEP_INDEX = STEP_INDEX
    def get_PREV_STEP_INDEX(self): return self.PREV_STEP_INDEX
    def set_PREV_STEP_INDEX(self, PREV_STEP_INDEX): self.PREV_STEP_INDEX = PREV_STEP_INDEX
    def add_PREV_STEP_INDEX(self, value): self.PREV_STEP_INDEX.append(value)
    def insert_PREV_STEP_INDEX_at(self, index, value): self.PREV_STEP_INDEX.insert(index, value)
    def replace_PREV_STEP_INDEX_at(self, index, value): self.PREV_STEP_INDEX[index] = value
    def get_PROGRAM(self): return self.PROGRAM
    def set_PROGRAM(self, PROGRAM): self.PROGRAM = PROGRAM
    def get_VERSION(self): return self.VERSION
    def set_VERSION(self, VERSION): self.VERSION = VERSION
    def get_NOTES(self): return self.NOTES
    def set_NOTES(self, NOTES): self.NOTES = NOTES
    def get_section_name(self): return self.section_name
    def set_section_name(self, section_name): self.section_name = section_name
    def hasContent_(self):
        if (
            self.STEP_INDEX is not None or
            self.PREV_STEP_INDEX or
            self.PROGRAM is not None or
            self.VERSION is not None or
            self.NOTES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PIPE_SECTIONType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PIPE_SECTIONType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PIPE_SECTIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PIPE_SECTIONType'):
        if self.section_name is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            outfile.write(' section_name=%s' % (self.gds_format_string(quote_attrib(self.section_name).encode(ExternalEncoding), input_name='section_name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PIPE_SECTIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STEP_INDEX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTEP_INDEX>%s</%sSTEP_INDEX>%s' % (namespace_, self.gds_format_string(quote_xml(self.STEP_INDEX).encode(ExternalEncoding), input_name='STEP_INDEX'), namespace_, eol_))
        for PREV_STEP_INDEX_ in self.PREV_STEP_INDEX:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STEP_INDEX>%s</%sPREV_STEP_INDEX>%s' % (namespace_, self.gds_format_string(quote_xml(PREV_STEP_INDEX_).encode(ExternalEncoding), input_name='PREV_STEP_INDEX'), namespace_, eol_))
        if self.PROGRAM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespace_, self.gds_format_string(quote_xml(self.PROGRAM).encode(ExternalEncoding), input_name='PROGRAM'), namespace_, eol_))
        if self.VERSION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVERSION>%s</%sVERSION>%s' % (namespace_, self.gds_format_string(quote_xml(self.VERSION).encode(ExternalEncoding), input_name='VERSION'), namespace_, eol_))
        if self.NOTES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNOTES>%s</%sNOTES>%s' % (namespace_, self.gds_format_string(quote_xml(self.NOTES).encode(ExternalEncoding), input_name='NOTES'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PIPE_SECTIONType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.section_name is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            showIndent(outfile, level)
            outfile.write('section_name="%s",\n' % (self.section_name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.STEP_INDEX is not None:
            showIndent(outfile, level)
            outfile.write('STEP_INDEX=%s,\n' % quote_python(self.STEP_INDEX).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('PREV_STEP_INDEX=[\n')
        level += 1
        for PREV_STEP_INDEX_ in self.PREV_STEP_INDEX:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PREV_STEP_INDEX_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PROGRAM is not None:
            showIndent(outfile, level)
            outfile.write('PROGRAM=%s,\n' % quote_python(self.PROGRAM).encode(ExternalEncoding))
        if self.VERSION is not None:
            showIndent(outfile, level)
            outfile.write('VERSION=%s,\n' % quote_python(self.VERSION).encode(ExternalEncoding))
        if self.NOTES is not None:
            showIndent(outfile, level)
            outfile.write('NOTES=%s,\n' % quote_python(self.NOTES).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('section_name', node)
        if value is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            self.section_name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STEP_INDEX':
            STEP_INDEX_ = child_.text
            STEP_INDEX_ = self.gds_validate_string(STEP_INDEX_, node, 'STEP_INDEX')
            self.STEP_INDEX = STEP_INDEX_
        elif nodeName_ == 'PREV_STEP_INDEX':
            PREV_STEP_INDEX_ = child_.text
            PREV_STEP_INDEX_ = self.gds_validate_string(PREV_STEP_INDEX_, node, 'PREV_STEP_INDEX')
            self.PREV_STEP_INDEX.append(PREV_STEP_INDEX_)
        elif nodeName_ == 'PROGRAM':
            PROGRAM_ = child_.text
            PROGRAM_ = self.gds_validate_string(PROGRAM_, node, 'PROGRAM')
            self.PROGRAM = PROGRAM_
        elif nodeName_ == 'VERSION':
            VERSION_ = child_.text
            VERSION_ = self.gds_validate_string(VERSION_, node, 'VERSION')
            self.VERSION = VERSION_
        elif nodeName_ == 'NOTES':
            NOTES_ = child_.text
            NOTES_ = self.gds_validate_string(NOTES_, node, 'NOTES')
            self.NOTES = NOTES_
# end class PIPE_SECTIONType


class STANDARDType(GeneratedsSuper):
    """A recognized name for the genome assembly.Identifies the genome
    assembly using an accession number and a sequence version."""
    subclass = None
    superclass = None
    def __init__(self, refname=None, accession=None):
        self.original_tagname_ = None
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)
    def factory(*args_, **kwargs_):
        if STANDARDType.subclass:
            return STANDARDType.subclass(*args_, **kwargs_)
        else:
            return STANDARDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refname(self): return self.refname
    def set_refname(self, refname): self.refname = refname
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='STANDARDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STANDARDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='STANDARDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STANDARDType'):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding), input_name='refname'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='STANDARDType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='STANDARDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            showIndent(outfile, level)
            outfile.write('refname="%s",\n' % (self.refname,))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.accession = ' '.join(self.accession.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class STANDARDType


class CUSTOMType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DESCRIPTION=None, URL_LINK=None):
        self.original_tagname_ = None
        self.DESCRIPTION = DESCRIPTION
        if URL_LINK is None:
            self.URL_LINK = []
        else:
            self.URL_LINK = URL_LINK
    def factory(*args_, **kwargs_):
        if CUSTOMType.subclass:
            return CUSTOMType.subclass(*args_, **kwargs_)
        else:
            return CUSTOMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_URL_LINK(self): return self.URL_LINK
    def set_URL_LINK(self, URL_LINK): self.URL_LINK = URL_LINK
    def add_URL_LINK(self, value): self.URL_LINK.append(value)
    def insert_URL_LINK_at(self, index, value): self.URL_LINK.insert(index, value)
    def replace_URL_LINK_at(self, index, value): self.URL_LINK[index] = value
    def hasContent_(self):
        if (
            self.DESCRIPTION is not None or
            self.URL_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CUSTOMType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CUSTOMType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CUSTOMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CUSTOMType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CUSTOMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DESCRIPTION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespace_, self.gds_format_string(quote_xml(self.DESCRIPTION).encode(ExternalEncoding), input_name='DESCRIPTION'), namespace_, eol_))
        for URL_LINK_ in self.URL_LINK:
            URL_LINK_.export(outfile, level, namespace_, name_='URL_LINK', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CUSTOMType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % quote_python(self.DESCRIPTION).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('URL_LINK=[\n')
        level += 1
        for URL_LINK_ in self.URL_LINK:
            showIndent(outfile, level)
            outfile.write('model_.URL_LINKType1(\n')
            URL_LINK_.exportLiteral(outfile, level, name_='URL_LINKType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
        elif nodeName_ == 'URL_LINK':
            obj_ = URL_LINKType1.factory()
            obj_.build(child_)
            self.URL_LINK.append(obj_)
            obj_.original_tagname_ = 'URL_LINK'
# end class CUSTOMType


class URL_LINKType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL
    def factory(*args_, **kwargs_):
        if URL_LINKType1.subclass:
            return URL_LINKType1.subclass(*args_, **kwargs_)
        else:
            return URL_LINKType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def hasContent_(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='URL_LINKType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL_LINKType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URL_LINKType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL_LINKType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URL_LINKType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='URL_LINKType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LABEL is not None:
            showIndent(outfile, level)
            outfile.write('LABEL=%s,\n' % quote_python(self.LABEL).encode(ExternalEncoding))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URL_LINKType1


class SEQUENCEType(GeneratedsSuper):
    """A recognized name for the reference sequence. Accession.version with
    version being mandatory This is how Reference Sequence is
    labeled in submission file(s). It is equivalent to SQ label in
    BAM. Optional when submitted file uses INSDC accession.version"""
    subclass = None
    superclass = None
    def __init__(self, label=None, refname=None, accession=None):
        self.original_tagname_ = None
        self.label = _cast(None, label)
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)
    def factory(*args_, **kwargs_):
        if SEQUENCEType.subclass:
            return SEQUENCEType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_refname(self): return self.refname
    def set_refname(self, refname): self.refname = refname
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SEQUENCEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SEQUENCEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SEQUENCEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SEQUENCEType'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding), input_name='refname'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SEQUENCEType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SEQUENCEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            showIndent(outfile, level)
            outfile.write('label="%s",\n' % (self.label,))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            showIndent(outfile, level)
            outfile.write('refname="%s",\n' % (self.refname,))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.accession = ' '.join(self.accession.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SEQUENCEType


class RunType(ObjectType):
    """A run contains a group of reads generated for a particular
    experiment. ISO date when the run took place. If applicable, the
    name of the contract sequencing center that executed the run.
    Example: 454MSC."""
    subclass = None
    superclass = ObjectType
    def __init__(self, center_name=None, alias=None, broker_name=None, accession=None, IDENTIFIERS=None, run_center=None, run_date=None, TITLE=None, EXPERIMENT_REF=None, SPOT_DESCRIPTOR=None, PLATFORM=None, PROCESSING=None, RUN_TYPE=None, DATA_BLOCK=None, RUN_LINKS=None, RUN_ATTRIBUTES=None):
        self.original_tagname_ = None
        super(RunType, self).__init__(center_name, alias, broker_name, accession, IDENTIFIERS, )
        self.run_center = _cast(None, run_center)
        if isinstance(run_date, basestring):
            initvalue_ = datetime_.datetime.strptime(run_date, '%Y-%m-%dT%H:%M:%S')
        else:
            initvalue_ = run_date
        self.run_date = initvalue_
        self.TITLE = TITLE
        self.EXPERIMENT_REF = EXPERIMENT_REF
        self.SPOT_DESCRIPTOR = SPOT_DESCRIPTOR
        self.PLATFORM = PLATFORM
        self.PROCESSING = PROCESSING
        self.RUN_TYPE = RUN_TYPE
        self.DATA_BLOCK = DATA_BLOCK
        self.RUN_LINKS = RUN_LINKS
        self.RUN_ATTRIBUTES = RUN_ATTRIBUTES
    def factory(*args_, **kwargs_):
        if RunType.subclass:
            return RunType.subclass(*args_, **kwargs_)
        else:
            return RunType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TITLE(self): return self.TITLE
    def set_TITLE(self, TITLE): self.TITLE = TITLE
    def get_EXPERIMENT_REF(self): return self.EXPERIMENT_REF
    def set_EXPERIMENT_REF(self, EXPERIMENT_REF): self.EXPERIMENT_REF = EXPERIMENT_REF
    def get_SPOT_DESCRIPTOR(self): return self.SPOT_DESCRIPTOR
    def set_SPOT_DESCRIPTOR(self, SPOT_DESCRIPTOR): self.SPOT_DESCRIPTOR = SPOT_DESCRIPTOR
    def get_PLATFORM(self): return self.PLATFORM
    def set_PLATFORM(self, PLATFORM): self.PLATFORM = PLATFORM
    def get_PROCESSING(self): return self.PROCESSING
    def set_PROCESSING(self, PROCESSING): self.PROCESSING = PROCESSING
    def get_RUN_TYPE(self): return self.RUN_TYPE
    def set_RUN_TYPE(self, RUN_TYPE): self.RUN_TYPE = RUN_TYPE
    def get_DATA_BLOCK(self): return self.DATA_BLOCK
    def set_DATA_BLOCK(self, DATA_BLOCK): self.DATA_BLOCK = DATA_BLOCK
    def get_RUN_LINKS(self): return self.RUN_LINKS
    def set_RUN_LINKS(self, RUN_LINKS): self.RUN_LINKS = RUN_LINKS
    def get_RUN_ATTRIBUTES(self): return self.RUN_ATTRIBUTES
    def set_RUN_ATTRIBUTES(self, RUN_ATTRIBUTES): self.RUN_ATTRIBUTES = RUN_ATTRIBUTES
    def get_run_center(self): return self.run_center
    def set_run_center(self, run_center): self.run_center = run_center
    def get_run_date(self): return self.run_date
    def set_run_date(self, run_date): self.run_date = run_date
    def hasContent_(self):
        if (
            self.TITLE is not None or
            self.EXPERIMENT_REF is not None or
            self.SPOT_DESCRIPTOR is not None or
            self.PLATFORM is not None or
            self.PROCESSING is not None or
            self.RUN_TYPE is not None or
            self.DATA_BLOCK is not None or
            self.RUN_LINKS is not None or
            self.RUN_ATTRIBUTES is not None or
            super(RunType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RunType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RunType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RunType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RunType'):
        super(RunType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='RunType')
        if self.run_center is not None and 'run_center' not in already_processed:
            already_processed.add('run_center')
            outfile.write(' run_center=%s' % (self.gds_format_string(quote_attrib(self.run_center).encode(ExternalEncoding), input_name='run_center'), ))
        if self.run_date is not None and 'run_date' not in already_processed:
            already_processed.add('run_date')
            outfile.write(' run_date="%s"' % self.gds_format_datetime(self.run_date, input_name='run_date'))
    def exportChildren(self, outfile, level, namespace_='', name_='RunType', fromsubclass_=False, pretty_print=True):
        super(RunType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespace_, self.gds_format_string(quote_xml(self.TITLE).encode(ExternalEncoding), input_name='TITLE'), namespace_, eol_))
        if self.EXPERIMENT_REF is not None:
            self.EXPERIMENT_REF.export(outfile, level, namespace_, name_='EXPERIMENT_REF', pretty_print=pretty_print)
        if self.SPOT_DESCRIPTOR is not None:
            self.SPOT_DESCRIPTOR.export(outfile, level, namespace_, name_='SPOT_DESCRIPTOR', pretty_print=pretty_print)
        if self.PLATFORM is not None:
            self.PLATFORM.export(outfile, level, namespace_, name_='PLATFORM', pretty_print=pretty_print)
        if self.PROCESSING is not None:
            self.PROCESSING.export(outfile, level, namespace_, name_='PROCESSING', pretty_print=pretty_print)
        if self.RUN_TYPE is not None:
            self.RUN_TYPE.export(outfile, level, namespace_, name_='RUN_TYPE', pretty_print=pretty_print)
        if self.DATA_BLOCK is not None:
            self.DATA_BLOCK.export(outfile, level, namespace_, name_='DATA_BLOCK', pretty_print=pretty_print)
        if self.RUN_LINKS is not None:
            self.RUN_LINKS.export(outfile, level, namespace_, name_='RUN_LINKS', pretty_print=pretty_print)
        if self.RUN_ATTRIBUTES is not None:
            self.RUN_ATTRIBUTES.export(outfile, level, namespace_, name_='RUN_ATTRIBUTES', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RunType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.run_center is not None and 'run_center' not in already_processed:
            already_processed.add('run_center')
            showIndent(outfile, level)
            outfile.write('run_center="%s",\n' % (self.run_center,))
        if self.run_date is not None and 'run_date' not in already_processed:
            already_processed.add('run_date')
            showIndent(outfile, level)
            outfile.write('run_date=model_.GeneratedsSuper.gds_parse_datetime("%s"),\n' % self.gds_format_datetime(self.run_date, input_name='run_date'))
        super(RunType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(RunType, self).exportLiteralChildren(outfile, level, name_)
        if self.TITLE is not None:
            showIndent(outfile, level)
            outfile.write('TITLE=%s,\n' % quote_python(self.TITLE).encode(ExternalEncoding))
        if self.EXPERIMENT_REF is not None:
            showIndent(outfile, level)
            outfile.write('EXPERIMENT_REF=model_.EXPERIMENT_REFType(\n')
            self.EXPERIMENT_REF.exportLiteral(outfile, level, name_='EXPERIMENT_REF')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SPOT_DESCRIPTOR is not None:
            showIndent(outfile, level)
            outfile.write('SPOT_DESCRIPTOR=model_.SpotDescriptorType(\n')
            self.SPOT_DESCRIPTOR.exportLiteral(outfile, level, name_='SPOT_DESCRIPTOR')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PLATFORM is not None:
            showIndent(outfile, level)
            outfile.write('PLATFORM=model_.PlatformType(\n')
            self.PLATFORM.exportLiteral(outfile, level, name_='PLATFORM')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PROCESSING is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSING=model_.ProcessingType(\n')
            self.PROCESSING.exportLiteral(outfile, level, name_='PROCESSING')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RUN_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('RUN_TYPE=model_.RUN_TYPEType(\n')
            self.RUN_TYPE.exportLiteral(outfile, level, name_='RUN_TYPE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DATA_BLOCK is not None:
            showIndent(outfile, level)
            outfile.write('DATA_BLOCK=model_.DATA_BLOCKType(\n')
            self.DATA_BLOCK.exportLiteral(outfile, level, name_='DATA_BLOCK')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RUN_LINKS is not None:
            showIndent(outfile, level)
            outfile.write('RUN_LINKS=model_.RUN_LINKSType(\n')
            self.RUN_LINKS.exportLiteral(outfile, level, name_='RUN_LINKS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.RUN_ATTRIBUTES is not None:
            showIndent(outfile, level)
            outfile.write('RUN_ATTRIBUTES=model_.RUN_ATTRIBUTESType(\n')
            self.RUN_ATTRIBUTES.exportLiteral(outfile, level, name_='RUN_ATTRIBUTES')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('run_center', node)
        if value is not None and 'run_center' not in already_processed:
            already_processed.add('run_center')
            self.run_center = value
        value = find_attr_value_('run_date', node)
        if value is not None and 'run_date' not in already_processed:
            already_processed.add('run_date')
            try:
                self.run_date = self.gds_parse_datetime(value)
            except ValueError as exp:
                raise ValueError('Bad date-time attribute (run_date): %s' % exp)
        super(RunType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TITLE':
            TITLE_ = child_.text
            TITLE_ = self.gds_validate_string(TITLE_, node, 'TITLE')
            self.TITLE = TITLE_
        elif nodeName_ == 'EXPERIMENT_REF':
            obj_ = EXPERIMENT_REFType.factory()
            obj_.build(child_)
            self.EXPERIMENT_REF = obj_
            obj_.original_tagname_ = 'EXPERIMENT_REF'
        elif nodeName_ == 'SPOT_DESCRIPTOR':
            obj_ = SpotDescriptorType.factory()
            obj_.build(child_)
            self.SPOT_DESCRIPTOR = obj_
            obj_.original_tagname_ = 'SPOT_DESCRIPTOR'
        elif nodeName_ == 'PLATFORM':
            obj_ = PlatformType.factory()
            obj_.build(child_)
            self.PLATFORM = obj_
            obj_.original_tagname_ = 'PLATFORM'
        elif nodeName_ == 'PROCESSING':
            obj_ = ProcessingType.factory()
            obj_.build(child_)
            self.PROCESSING = obj_
            obj_.original_tagname_ = 'PROCESSING'
        elif nodeName_ == 'RUN_TYPE':
            obj_ = RUN_TYPEType.factory()
            obj_.build(child_)
            self.RUN_TYPE = obj_
            obj_.original_tagname_ = 'RUN_TYPE'
        elif nodeName_ == 'DATA_BLOCK':
            obj_ = DATA_BLOCKType.factory()
            obj_.build(child_)
            self.DATA_BLOCK = obj_
            obj_.original_tagname_ = 'DATA_BLOCK'
        elif nodeName_ == 'RUN_LINKS':
            obj_ = RUN_LINKSType.factory()
            obj_.build(child_)
            self.RUN_LINKS = obj_
            obj_.original_tagname_ = 'RUN_LINKS'
        elif nodeName_ == 'RUN_ATTRIBUTES':
            obj_ = RUN_ATTRIBUTESType.factory()
            obj_.build(child_)
            self.RUN_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'RUN_ATTRIBUTES'
        super(RunType, self).buildChildren(child_, node, nodeName_, True)
# end class RunType


GDSClassesMapping = {
    'IDENTIFIERS': IdentifierType,
    'OXFORD_NANOPORE': OXFORD_NANOPOREType,
    'SPOT_DESCRIPTOR': SpotDescriptorType,
    'RUN_ATTRIBUTE': AttributeType,
    'FILE': FILEType,
    'COMPLETE_GENOMICS': COMPLETE_GENOMICSType,
    'RUN_TYPE': RUN_TYPEType,
    'LS454': LS454Type,
    'ILLUMINA': ILLUMINAType,
    'REFERENCE_ALIGNMENT': ReferenceSequenceType,
    'CUSTOM': CUSTOMType,
    'PRIMARY_ID': NameType,
    'PLATFORM': PlatformType,
    'PIPE_SECTION': PIPE_SECTIONType,
    'ENTREZ_LINK': ENTREZ_LINKType,
    'RUN_ATTRIBUTES': RUN_ATTRIBUTESType,
    'RUN_LINK': LinkType,
    'XREF_LINK': XRefType,
    'CAPILLARY': CAPILLARYType,
    'ABI_SOLID': ABI_SOLIDType,
    'ASSEMBLY': ReferenceAssemblyType,
    'EXPERIMENT_REF': EXPERIMENT_REFType,
    'SEQUENCE': SEQUENCEType,
    'PROCESSING': ProcessingType,
    'RUN_LINKS': RUN_LINKSType,
    'STANDARD': STANDARDType,
    'RUN_SET': RunSetType,
    'ION_TORRENT': ION_TORRENTType,
    'SPOT_DECODE_SPEC': SPOT_DECODE_SPECType,
    'EXPECTED_BASECALL_TABLE': EXPECTED_BASECALL_TABLEType,
    'BASECALL': BASECALLType,
    'HELICOS': HELICOSType,
    'FILES': FILESType,
    'PIPELINE': PipelineType,
    'RUN': RunType,
    'UUID': NameType,
    'DATA_BLOCK': DATA_BLOCKType,
    'URL_LINK': URL_LINKType1,
    'SUBMITTER_ID': QualifiedNameType,
    'BGISEQ': BGISEQType,
    'SECONDARY_ID': NameType,
    'RELATIVE_ORDER': RELATIVE_ORDERType,
    'DIRECTIVES': SequencingDirectivesType,
    'PACBIO_SMRT': PACBIO_SMRTType,
    'EXTERNAL_ID': QualifiedNameType,
    'READ_SPEC': READ_SPECType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RunType'
        rootClass = RunType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RunType'
        rootClass = RunType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RunType'
        rootClass = RunType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'RunType'
        rootClass = RunType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from run_api import *\n\n')
        sys.stdout.write('import run_api as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ABI_SOLIDType",
    "AttributeType",
    "BASECALLType",
    "BGISEQType",
    "CAPILLARYType",
    "COMPLETE_GENOMICSType",
    "CUSTOMType",
    "DATA_BLOCKType",
    "ENTREZ_LINKType",
    "EXPECTED_BASECALL_TABLEType",
    "EXPERIMENT_REFType",
    "FILESType",
    "FILEType",
    "HELICOSType",
    "ILLUMINAType",
    "ION_TORRENTType",
    "IdentifierType",
    "LS454Type",
    "LinkType",
    "NameType",
    "OXFORD_NANOPOREType",
    "ObjectType",
    "PACBIO_SMRTType",
    "PIPE_SECTIONType",
    "PipelineType",
    "PlatformType",
    "ProcessingType",
    "QualifiedNameType",
    "READ_SPECType",
    "RELATIVE_ORDERType",
    "RUN_ATTRIBUTESType",
    "RUN_LINKSType",
    "RUN_TYPEType",
    "RefObjectType",
    "ReferenceAssemblyType",
    "ReferenceSequenceType",
    "RunSetType",
    "RunType",
    "SEQUENCEType",
    "SPOT_DECODE_SPECType",
    "STANDARDType",
    "SequencingDirectivesType",
    "SpotDescriptorType",
    "URLType",
    "URL_LINKType",
    "URL_LINKType1",
    "XRefType"
]
