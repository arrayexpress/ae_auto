#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
# Generated Mon Mar 13 15:44:46 2017 by generateDS.py version 2.16a.
#
# Command line options:
#   ('-f', '')
#   ('-o', 'experiment_api.py')
#
# Command line arguments:
#   sra_schema_files/SRA.experiment.xsd
#
# Command line:
#   /home/gemmy/generateDS-2.16a0/generateDS.py -f -o "experiment_api.py" sra_schema_files/SRA.experiment.xsd
#
# Current working directory (os.getcwd()):
#   sra_xml
#

import sys
import re as re_
import base64
import datetime as datetime_
import warnings as warnings_
from lxml import etree as etree_


Validate_simpletypes_ = True


def parsexml_(infile, parser=None, **kwargs):
    if parser is None:
        # Use the lxml ElementTree compatible parser so that, e.g.,
        #   we ignore comments.
        parser = etree_.ETCompatXMLParser()
    doc = etree_.parse(infile, parser=parser, **kwargs)
    return doc

#
# User methods
#
# Calls to the methods in these classes are generated by generateDS.py.
# You can replace these methods by re-implementing the following class
#   in a module named generatedssuper.py.

try:
    from generatedssuper import GeneratedsSuper
except ImportError as exp:

    class GeneratedsSuper(object):
        tzoff_pattern = re_.compile(r'(\+|-)((0\d|1[0-3]):[0-5]\d|14:00)$')
        class _FixedOffsetTZ(datetime_.tzinfo):
            def __init__(self, offset, name):
                self.__offset = datetime_.timedelta(minutes=offset)
                self.__name = name
            def utcoffset(self, dt):
                return self.__offset
            def tzname(self, dt):
                return self.__name
            def dst(self, dt):
                return None
        def gds_format_string(self, input_data, input_name=''):
            return input_data
        def gds_validate_string(self, input_data, node=None, input_name=''):
            if not input_data:
                return ''
            else:
                return input_data
        def gds_format_base64(self, input_data, input_name=''):
            return base64.b64encode(input_data)
        def gds_validate_base64(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer(self, input_data, input_name=''):
            return '%d' % input_data
        def gds_validate_integer(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_integer_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_integer_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    int(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of integers')
            return values
        def gds_format_float(self, input_data, input_name=''):
            return ('%.15f' % input_data).rstrip('0')
        def gds_validate_float(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_float_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_float_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of floats')
            return values
        def gds_format_double(self, input_data, input_name=''):
            return '%e' % input_data
        def gds_validate_double(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_double_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_double_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                try:
                    float(value)
                except (TypeError, ValueError):
                    raise_parse_error(node, 'Requires sequence of doubles')
            return values
        def gds_format_boolean(self, input_data, input_name=''):
            return ('%s' % input_data).lower()
        def gds_validate_boolean(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_boolean_list(self, input_data, input_name=''):
            return '%s' % ' '.join(input_data)
        def gds_validate_boolean_list(
                self, input_data, node=None, input_name=''):
            values = input_data.split()
            for value in values:
                if value not in ('true', '1', 'false', '0', ):
                    raise_parse_error(
                        node,
                        'Requires sequence of booleans '
                        '("true", "1", "false", "0")')
            return values
        def gds_validate_datetime(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_datetime(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%04d-%02d-%02dT%02d:%02d:%02d.%s' % (
                    input_data.year,
                    input_data.month,
                    input_data.day,
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        @classmethod
        def gds_parse_datetime(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            time_parts = input_data.split('.')
            if len(time_parts) > 1:
                micro_seconds = int(float('0.' + time_parts[1]) * 1000000)
                input_data = '%s.%s' % (time_parts[0], micro_seconds, )
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(
                    input_data, '%Y-%m-%dT%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt
        def gds_validate_date(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_date(self, input_data, input_name=''):
            _svalue = '%04d-%02d-%02d' % (
                input_data.year,
                input_data.month,
                input_data.day,
            )
            try:
                if input_data.tzinfo is not None:
                    tzoff = input_data.tzinfo.utcoffset(input_data)
                    if tzoff is not None:
                        total_seconds = tzoff.seconds + (86400 * tzoff.days)
                        if total_seconds == 0:
                            _svalue += 'Z'
                        else:
                            if total_seconds < 0:
                                _svalue += '-'
                                total_seconds *= -1
                            else:
                                _svalue += '+'
                            hours = total_seconds // 3600
                            minutes = (total_seconds - (hours * 3600)) // 60
                            _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            except AttributeError:
                pass
            return _svalue
        @classmethod
        def gds_parse_date(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            dt = datetime_.datetime.strptime(input_data, '%Y-%m-%d')
            dt = dt.replace(tzinfo=tz)
            return dt.date()
        def gds_validate_time(self, input_data, node=None, input_name=''):
            return input_data
        def gds_format_time(self, input_data, input_name=''):
            if input_data.microsecond == 0:
                _svalue = '%02d:%02d:%02d' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                )
            else:
                _svalue = '%02d:%02d:%02d.%s' % (
                    input_data.hour,
                    input_data.minute,
                    input_data.second,
                    ('%f' % (float(input_data.microsecond) / 1000000))[2:],
                )
            if input_data.tzinfo is not None:
                tzoff = input_data.tzinfo.utcoffset(input_data)
                if tzoff is not None:
                    total_seconds = tzoff.seconds + (86400 * tzoff.days)
                    if total_seconds == 0:
                        _svalue += 'Z'
                    else:
                        if total_seconds < 0:
                            _svalue += '-'
                            total_seconds *= -1
                        else:
                            _svalue += '+'
                        hours = total_seconds // 3600
                        minutes = (total_seconds - (hours * 3600)) // 60
                        _svalue += '{0:02d}:{1:02d}'.format(hours, minutes)
            return _svalue
        def gds_validate_simple_patterns(self, patterns, target):
            # pat is a list of lists of strings/patterns.  We should:
            # - AND the outer elements
            # - OR the inner elements
            found1 = True
            for patterns1 in patterns:
                found2 = False
                for patterns2 in patterns1:
                    if re_.search(patterns2, target) is not None:
                        found2 = True
                        break
                if not found2:
                    found1 = False
                    break
            return found1
        @classmethod
        def gds_parse_time(cls, input_data):
            tz = None
            if input_data[-1] == 'Z':
                tz = GeneratedsSuper._FixedOffsetTZ(0, 'UTC')
                input_data = input_data[:-1]
            else:
                results = GeneratedsSuper.tzoff_pattern.search(input_data)
                if results is not None:
                    tzoff_parts = results.group(2).split(':')
                    tzoff = int(tzoff_parts[0]) * 60 + int(tzoff_parts[1])
                    if results.group(1) == '-':
                        tzoff *= -1
                    tz = GeneratedsSuper._FixedOffsetTZ(
                        tzoff, results.group(0))
                    input_data = input_data[:-6]
            if len(input_data.split('.')) > 1:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S.%f')
            else:
                dt = datetime_.datetime.strptime(input_data, '%H:%M:%S')
            dt = dt.replace(tzinfo=tz)
            return dt.time()
        def gds_str_lower(self, instring):
            return instring.lower()
        def get_path_(self, node):
            path_list = []
            self.get_path_list_(node, path_list)
            path_list.reverse()
            path = '/'.join(path_list)
            return path
        Tag_strip_pattern_ = re_.compile(r'\{.*\}')
        def get_path_list_(self, node, path_list):
            if node is None:
                return
            tag = GeneratedsSuper.Tag_strip_pattern_.sub('', node.tag)
            if tag:
                path_list.append(tag)
            self.get_path_list_(node.getparent(), path_list)
        def get_class_obj_(self, node, default_class=None):
            class_obj1 = default_class
            if 'xsi' in node.nsmap:
                classname = node.get('{%s}type' % node.nsmap['xsi'])
                if classname is not None:
                    names = classname.split(':')
                    if len(names) == 2:
                        classname = names[1]
                    class_obj2 = globals().get(classname)
                    if class_obj2 is not None:
                        class_obj1 = class_obj2
            return class_obj1
        def gds_build_any(self, node, type_name=None):
            return None
        @classmethod
        def gds_reverse_node_mapping(cls, mapping):
            return dict(((v, k) for k, v in mapping.iteritems()))


#
# If you have installed IPython you can uncomment and use the following.
# IPython is available from http://ipython.scipy.org/.
#

## from IPython.Shell import IPShellEmbed
## args = ''
## ipshell = IPShellEmbed(args,
##     banner = 'Dropping into IPython',
##     exit_msg = 'Leaving Interpreter, back to program.')

# Then use the following line where and when you want to drop into the
# IPython shell:
#    ipshell('<some message> -- Entering ipshell.\nHit Ctrl-D to exit')

#
# Globals
#

ExternalEncoding = 'utf8'
Tag_pattern_ = re_.compile(r'({.*})?(.*)')
String_cleanup_pat_ = re_.compile(r"[\n\r\s]+")
Namespace_extract_pat_ = re_.compile(r'{(.*)}(.*)')
CDATA_pattern_ = re_.compile(r"<!\[CDATA\[.*?\]\]>", re_.DOTALL)

#
# Support/utility functions.
#


def showIndent(outfile, level, pretty_print=True):
    if pretty_print:
        for idx in range(level):
            outfile.write('    ')


def quote_xml(inStr):
    "Escape markup chars, but do not modify CDATA sections."
    if not inStr:
        return ''
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s2 = ''
    pos = 0
    matchobjects = CDATA_pattern_.finditer(s1)
    for mo in matchobjects:
        s3 = s1[pos:mo.start()]
        s2 += quote_xml_aux(s3)
        s2 += s1[mo.start():mo.end()]
        pos = mo.end()
    s3 = s1[pos:]
    s2 += quote_xml_aux(s3)
    return s2


def quote_xml_aux(inStr):
    s1 = inStr.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    return s1


def quote_attrib(inStr):
    s1 = (isinstance(inStr, basestring) and inStr or
          '%s' % inStr)
    s1 = s1.replace('&', '&amp;')
    s1 = s1.replace('<', '&lt;')
    s1 = s1.replace('>', '&gt;')
    if '"' in s1:
        if "'" in s1:
            s1 = '"%s"' % s1.replace('"', "&quot;")
        else:
            s1 = "'%s'" % s1
    else:
        s1 = '"%s"' % s1
    return s1


def quote_python(inStr):
    s1 = inStr
    if s1.find("'") == -1:
        if s1.find('\n') == -1:
            return "'%s'" % s1
        else:
            return "'''%s'''" % s1
    else:
        if s1.find('"') != -1:
            s1 = s1.replace('"', '\\"')
        if s1.find('\n') == -1:
            return '"%s"' % s1
        else:
            return '"""%s"""' % s1


def get_all_text_(node):
    if node.text is not None:
        text = node.text
    else:
        text = ''
    for child in node:
        if child.tail is not None:
            text += child.tail
    return text


def find_attr_value_(attr_name, node):
    attrs = node.attrib
    attr_parts = attr_name.split(':')
    value = None
    if len(attr_parts) == 1:
        value = attrs.get(attr_name)
    elif len(attr_parts) == 2:
        prefix, name = attr_parts
        namespace = node.nsmap.get(prefix)
        if namespace is not None:
            value = attrs.get('{%s}%s' % (namespace, name, ))
    return value


class GDSParseError(Exception):
    pass


def raise_parse_error(node, msg):
    msg = '%s (element %s/line %d)' % (msg, node.tag, node.sourceline, )
    raise GDSParseError(msg)


class MixedContainer:
    # Constants for category:
    CategoryNone = 0
    CategoryText = 1
    CategorySimple = 2
    CategoryComplex = 3
    # Constants for content_type:
    TypeNone = 0
    TypeText = 1
    TypeString = 2
    TypeInteger = 3
    TypeFloat = 4
    TypeDecimal = 5
    TypeDouble = 6
    TypeBoolean = 7
    TypeBase64 = 8
    def __init__(self, category, content_type, name, value):
        self.category = category
        self.content_type = content_type
        self.name = name
        self.value = value
    def getCategory(self):
        return self.category
    def getContenttype(self, content_type):
        return self.content_type
    def getValue(self):
        return self.value
    def getName(self):
        return self.name
    def export(self, outfile, level, name, namespace, pretty_print=True):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                outfile.write(self.value)
        elif self.category == MixedContainer.CategorySimple:
            self.exportSimple(outfile, level, name)
        else:    # category == MixedContainer.CategoryComplex
            self.value.export(outfile, level, namespace, name, pretty_print)
    def exportSimple(self, outfile, level, name):
        if self.content_type == MixedContainer.TypeString:
            outfile.write('<%s>%s</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeInteger or \
                self.content_type == MixedContainer.TypeBoolean:
            outfile.write('<%s>%d</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeFloat or \
                self.content_type == MixedContainer.TypeDecimal:
            outfile.write('<%s>%f</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeDouble:
            outfile.write('<%s>%g</%s>' % (
                self.name, self.value, self.name))
        elif self.content_type == MixedContainer.TypeBase64:
            outfile.write('<%s>%s</%s>' % (
                self.name, base64.b64encode(self.value), self.name))
    def to_etree(self, element):
        if self.category == MixedContainer.CategoryText:
            # Prevent exporting empty content as empty lines.
            if self.value.strip():
                if len(element) > 0:
                    if element[-1].tail is None:
                        element[-1].tail = self.value
                    else:
                        element[-1].tail += self.value
                else:
                    if element.text is None:
                        element.text = self.value
                    else:
                        element.text += self.value
        elif self.category == MixedContainer.CategorySimple:
            subelement = etree_.SubElement(element, '%s' % self.name)
            subelement.text = self.to_etree_simple()
        else:    # category == MixedContainer.CategoryComplex
            self.value.to_etree(element)
    def to_etree_simple(self):
        if self.content_type == MixedContainer.TypeString:
            text = self.value
        elif (self.content_type == MixedContainer.TypeInteger or
                self.content_type == MixedContainer.TypeBoolean):
            text = '%d' % self.value
        elif (self.content_type == MixedContainer.TypeFloat or
                self.content_type == MixedContainer.TypeDecimal):
            text = '%f' % self.value
        elif self.content_type == MixedContainer.TypeDouble:
            text = '%g' % self.value
        elif self.content_type == MixedContainer.TypeBase64:
            text = '%s' % base64.b64encode(self.value)
        return text
    def exportLiteral(self, outfile, level, name):
        if self.category == MixedContainer.CategoryText:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        elif self.category == MixedContainer.CategorySimple:
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s", "%s"),\n' % (
                    self.category, self.content_type, self.name, self.value))
        else:    # category == MixedContainer.CategoryComplex
            showIndent(outfile, level)
            outfile.write(
                'model_.MixedContainer(%d, %d, "%s",\n' % (
                    self.category, self.content_type, self.name,))
            self.value.exportLiteral(outfile, level + 1)
            showIndent(outfile, level)
            outfile.write(')\n')


class MemberSpec_(object):
    def __init__(self, name='', data_type='', container=0):
        self.name = name
        self.data_type = data_type
        self.container = container
    def set_name(self, name): self.name = name
    def get_name(self): return self.name
    def set_data_type(self, data_type): self.data_type = data_type
    def get_data_type_chain(self): return self.data_type
    def get_data_type(self):
        if isinstance(self.data_type, list):
            if len(self.data_type) > 0:
                return self.data_type[-1]
            else:
                return 'xs:string'
        else:
            return self.data_type
    def set_container(self, container): self.container = container
    def get_container(self): return self.container


def _cast(typ, value):
    if typ is None or value is None:
        return value
    return typ(value)

#
# Data representation classes.
#


class LibraryDescriptorType(GeneratedsSuper):
    """The LIBRARY_DESCRIPTOR specifies the origin of the material being
    sequenced and any treatments that the material might have
    undergone that affect the sequencing result. This specification
    is needed even if the platform does not require a library
    construction step per se."""
    subclass = None
    superclass = None
    def __init__(self, LIBRARY_NAME=None, LIBRARY_STRATEGY=None, LIBRARY_SOURCE=None, LIBRARY_SELECTION=None, LIBRARY_LAYOUT=None, TARGETED_LOCI=None, POOLING_STRATEGY=None, LIBRARY_CONSTRUCTION_PROTOCOL=None):
        self.original_tagname_ = None
        self.LIBRARY_NAME = LIBRARY_NAME
        self.LIBRARY_STRATEGY = LIBRARY_STRATEGY
        self.validate_typeLibraryStrategy(self.LIBRARY_STRATEGY)
        self.LIBRARY_SOURCE = LIBRARY_SOURCE
        self.validate_typeLibrarySource(self.LIBRARY_SOURCE)
        self.LIBRARY_SELECTION = LIBRARY_SELECTION
        self.validate_typeLibrarySelection(self.LIBRARY_SELECTION)
        self.LIBRARY_LAYOUT = LIBRARY_LAYOUT
        self.TARGETED_LOCI = TARGETED_LOCI
        self.POOLING_STRATEGY = POOLING_STRATEGY
        self.validate_POOLING_STRATEGYType(self.POOLING_STRATEGY)
        self.LIBRARY_CONSTRUCTION_PROTOCOL = LIBRARY_CONSTRUCTION_PROTOCOL
    def factory(*args_, **kwargs_):
        if LibraryDescriptorType.subclass:
            return LibraryDescriptorType.subclass(*args_, **kwargs_)
        else:
            return LibraryDescriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LIBRARY_NAME(self): return self.LIBRARY_NAME
    def set_LIBRARY_NAME(self, LIBRARY_NAME): self.LIBRARY_NAME = LIBRARY_NAME
    def get_LIBRARY_STRATEGY(self): return self.LIBRARY_STRATEGY
    def set_LIBRARY_STRATEGY(self, LIBRARY_STRATEGY): self.LIBRARY_STRATEGY = LIBRARY_STRATEGY
    def get_LIBRARY_SOURCE(self): return self.LIBRARY_SOURCE
    def set_LIBRARY_SOURCE(self, LIBRARY_SOURCE): self.LIBRARY_SOURCE = LIBRARY_SOURCE
    def get_LIBRARY_SELECTION(self): return self.LIBRARY_SELECTION
    def set_LIBRARY_SELECTION(self, LIBRARY_SELECTION): self.LIBRARY_SELECTION = LIBRARY_SELECTION
    def get_LIBRARY_LAYOUT(self): return self.LIBRARY_LAYOUT
    def set_LIBRARY_LAYOUT(self, LIBRARY_LAYOUT): self.LIBRARY_LAYOUT = LIBRARY_LAYOUT
    def get_TARGETED_LOCI(self): return self.TARGETED_LOCI
    def set_TARGETED_LOCI(self, TARGETED_LOCI): self.TARGETED_LOCI = TARGETED_LOCI
    def get_POOLING_STRATEGY(self): return self.POOLING_STRATEGY
    def set_POOLING_STRATEGY(self, POOLING_STRATEGY): self.POOLING_STRATEGY = POOLING_STRATEGY
    def get_LIBRARY_CONSTRUCTION_PROTOCOL(self): return self.LIBRARY_CONSTRUCTION_PROTOCOL
    def set_LIBRARY_CONSTRUCTION_PROTOCOL(self, LIBRARY_CONSTRUCTION_PROTOCOL): self.LIBRARY_CONSTRUCTION_PROTOCOL = LIBRARY_CONSTRUCTION_PROTOCOL
    def validate_typeLibraryStrategy(self, value):
        # Validate type typeLibraryStrategy, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['WGS', 'WGA', 'WXS', 'RNA-Seq', 'ssRNA-seq', 'miRNA-Seq', 'ncRNA-Seq', 'FL-cDNA', 'EST', 'Hi-C', 'ATAC-seq', 'WCS', 'RAD-Seq', 'CLONE', 'POOLCLONE', 'AMPLICON', 'CLONEEND', 'FINISHING', 'ChIP-Seq', 'MNase-Seq', 'DNase-Hypersensitivity', 'Bisulfite-Seq', 'CTS', 'MRE-Seq', 'MeDIP-Seq', 'MBD-Seq', 'Tn-Seq', 'VALIDATION', 'FAIRE-seq', 'SELEX', 'RIP-Seq', 'ChIA-PET', 'Synthetic-Long-Read', 'Targeted-Capture', 'Tethered Chromatin Conformation Capture', 'OTHER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeLibraryStrategy' % {"value" : value.encode("utf-8")} )
    def validate_typeLibrarySource(self, value):
        # Validate type typeLibrarySource, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['GENOMIC', 'GENOMIC SINGLE CELL', 'TRANSCRIPTOMIC', 'TRANSCRIPTOMIC SINGLE CELL', 'METAGENOMIC', 'METATRANSCRIPTOMIC', 'SYNTHETIC', 'VIRAL RNA', 'OTHER']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeLibrarySource' % {"value" : value.encode("utf-8")} )
    def validate_typeLibrarySelection(self, value):
        # Validate type typeLibrarySelection, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['RANDOM', 'PCR', 'RANDOM PCR', 'RT-PCR', 'HMPR', 'MF', 'repeat fractionation', 'size fractionation', 'MSLL', 'cDNA', 'cDNA_randomPriming', 'cDNA_oligo_dT', 'PolyA', 'Oligo-dT', 'Inverse rRNA', 'Inverse rRNA selection', 'ChIP', 'MNase', 'DNase', 'Hybrid Selection', 'Reduced Representation', 'Restriction Digest', '5-methylcytidine antibody', 'MBD2 protein methyl-CpG binding domain', 'CAGE', 'RACE', 'MDA', 'padlock probes capture method', 'other', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeLibrarySelection' % {"value" : value.encode("utf-8")} )
    def validate_POOLING_STRATEGYType(self, value):
        # Validate type POOLING_STRATEGYType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            pass
    def hasContent_(self):
        if (
            self.LIBRARY_NAME is not None or
            self.LIBRARY_STRATEGY is not None or
            self.LIBRARY_SOURCE is not None or
            self.LIBRARY_SELECTION is not None or
            self.LIBRARY_LAYOUT is not None or
            self.TARGETED_LOCI is not None or
            self.POOLING_STRATEGY is not None or
            self.LIBRARY_CONSTRUCTION_PROTOCOL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LibraryDescriptorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LibraryDescriptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LibraryDescriptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LibraryDescriptorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LibraryDescriptorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LIBRARY_NAME is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIBRARY_NAME>%s</%sLIBRARY_NAME>%s' % (namespace_, self.gds_format_string(quote_xml(self.LIBRARY_NAME).encode(ExternalEncoding), input_name='LIBRARY_NAME'), namespace_, eol_))
        if self.LIBRARY_STRATEGY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIBRARY_STRATEGY>%s</%sLIBRARY_STRATEGY>%s' % (namespace_, self.gds_format_string(quote_xml(self.LIBRARY_STRATEGY).encode(ExternalEncoding), input_name='LIBRARY_STRATEGY'), namespace_, eol_))
        if self.LIBRARY_SOURCE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIBRARY_SOURCE>%s</%sLIBRARY_SOURCE>%s' % (namespace_, self.gds_format_string(quote_xml(self.LIBRARY_SOURCE).encode(ExternalEncoding), input_name='LIBRARY_SOURCE'), namespace_, eol_))
        if self.LIBRARY_SELECTION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIBRARY_SELECTION>%s</%sLIBRARY_SELECTION>%s' % (namespace_, self.gds_format_string(quote_xml(self.LIBRARY_SELECTION).encode(ExternalEncoding), input_name='LIBRARY_SELECTION'), namespace_, eol_))
        if self.LIBRARY_LAYOUT is not None:
            self.LIBRARY_LAYOUT.export(outfile, level, namespace_, name_='LIBRARY_LAYOUT', pretty_print=pretty_print)
        if self.TARGETED_LOCI is not None:
            self.TARGETED_LOCI.export(outfile, level, namespace_, name_='TARGETED_LOCI', pretty_print=pretty_print)
        if self.POOLING_STRATEGY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPOOLING_STRATEGY>%s</%sPOOLING_STRATEGY>%s' % (namespace_, self.gds_format_string(quote_xml(self.POOLING_STRATEGY).encode(ExternalEncoding), input_name='POOLING_STRATEGY'), namespace_, eol_))
        if self.LIBRARY_CONSTRUCTION_PROTOCOL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLIBRARY_CONSTRUCTION_PROTOCOL>%s</%sLIBRARY_CONSTRUCTION_PROTOCOL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LIBRARY_CONSTRUCTION_PROTOCOL).encode(ExternalEncoding), input_name='LIBRARY_CONSTRUCTION_PROTOCOL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LibraryDescriptorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LIBRARY_NAME is not None:
            showIndent(outfile, level)
            outfile.write('LIBRARY_NAME=%s,\n' % quote_python(self.LIBRARY_NAME).encode(ExternalEncoding))
        if self.LIBRARY_STRATEGY is not None:
            showIndent(outfile, level)
            outfile.write('LIBRARY_STRATEGY=%s,\n' % quote_python(self.LIBRARY_STRATEGY).encode(ExternalEncoding))
        if self.LIBRARY_SOURCE is not None:
            showIndent(outfile, level)
            outfile.write('LIBRARY_SOURCE=%s,\n' % quote_python(self.LIBRARY_SOURCE).encode(ExternalEncoding))
        if self.LIBRARY_SELECTION is not None:
            showIndent(outfile, level)
            outfile.write('LIBRARY_SELECTION=%s,\n' % quote_python(self.LIBRARY_SELECTION).encode(ExternalEncoding))
        if self.LIBRARY_LAYOUT is not None:
            showIndent(outfile, level)
            outfile.write('LIBRARY_LAYOUT=model_.LIBRARY_LAYOUTType(\n')
            self.LIBRARY_LAYOUT.exportLiteral(outfile, level, name_='LIBRARY_LAYOUT')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.TARGETED_LOCI is not None:
            showIndent(outfile, level)
            outfile.write('TARGETED_LOCI=model_.TARGETED_LOCIType(\n')
            self.TARGETED_LOCI.exportLiteral(outfile, level, name_='TARGETED_LOCI')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.POOLING_STRATEGY is not None:
            showIndent(outfile, level)
            outfile.write('POOLING_STRATEGY=%s,\n' % quote_python(self.POOLING_STRATEGY).encode(ExternalEncoding))
        if self.LIBRARY_CONSTRUCTION_PROTOCOL is not None:
            showIndent(outfile, level)
            outfile.write('LIBRARY_CONSTRUCTION_PROTOCOL=%s,\n' % quote_python(self.LIBRARY_CONSTRUCTION_PROTOCOL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LIBRARY_NAME':
            LIBRARY_NAME_ = child_.text
            LIBRARY_NAME_ = self.gds_validate_string(LIBRARY_NAME_, node, 'LIBRARY_NAME')
            self.LIBRARY_NAME = LIBRARY_NAME_
        elif nodeName_ == 'LIBRARY_STRATEGY':
            LIBRARY_STRATEGY_ = child_.text
            LIBRARY_STRATEGY_ = self.gds_validate_string(LIBRARY_STRATEGY_, node, 'LIBRARY_STRATEGY')
            self.LIBRARY_STRATEGY = LIBRARY_STRATEGY_
            # validate type typeLibraryStrategy
            self.validate_typeLibraryStrategy(self.LIBRARY_STRATEGY)
        elif nodeName_ == 'LIBRARY_SOURCE':
            LIBRARY_SOURCE_ = child_.text
            LIBRARY_SOURCE_ = self.gds_validate_string(LIBRARY_SOURCE_, node, 'LIBRARY_SOURCE')
            self.LIBRARY_SOURCE = LIBRARY_SOURCE_
            # validate type typeLibrarySource
            self.validate_typeLibrarySource(self.LIBRARY_SOURCE)
        elif nodeName_ == 'LIBRARY_SELECTION':
            LIBRARY_SELECTION_ = child_.text
            LIBRARY_SELECTION_ = self.gds_validate_string(LIBRARY_SELECTION_, node, 'LIBRARY_SELECTION')
            self.LIBRARY_SELECTION = LIBRARY_SELECTION_
            # validate type typeLibrarySelection
            self.validate_typeLibrarySelection(self.LIBRARY_SELECTION)
        elif nodeName_ == 'LIBRARY_LAYOUT':
            obj_ = LIBRARY_LAYOUTType.factory()
            obj_.build(child_)
            self.LIBRARY_LAYOUT = obj_
            obj_.original_tagname_ = 'LIBRARY_LAYOUT'
        elif nodeName_ == 'TARGETED_LOCI':
            obj_ = TARGETED_LOCIType.factory()
            obj_.build(child_)
            self.TARGETED_LOCI = obj_
            obj_.original_tagname_ = 'TARGETED_LOCI'
        elif nodeName_ == 'POOLING_STRATEGY':
            POOLING_STRATEGY_ = child_.text
            POOLING_STRATEGY_ = self.gds_validate_string(POOLING_STRATEGY_, node, 'POOLING_STRATEGY')
            self.POOLING_STRATEGY = POOLING_STRATEGY_
            # validate type POOLING_STRATEGYType
            self.validate_POOLING_STRATEGYType(self.POOLING_STRATEGY)
        elif nodeName_ == 'LIBRARY_CONSTRUCTION_PROTOCOL':
            LIBRARY_CONSTRUCTION_PROTOCOL_ = child_.text
            LIBRARY_CONSTRUCTION_PROTOCOL_ = self.gds_validate_string(LIBRARY_CONSTRUCTION_PROTOCOL_, node, 'LIBRARY_CONSTRUCTION_PROTOCOL')
            self.LIBRARY_CONSTRUCTION_PROTOCOL = LIBRARY_CONSTRUCTION_PROTOCOL_
# end class LibraryDescriptorType


class LibraryType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DESIGN_DESCRIPTION=None, SAMPLE_DESCRIPTOR=None, LIBRARY_DESCRIPTOR=None, SPOT_DESCRIPTOR=None):
        self.original_tagname_ = None
        self.DESIGN_DESCRIPTION = DESIGN_DESCRIPTION
        self.SAMPLE_DESCRIPTOR = SAMPLE_DESCRIPTOR
        self.LIBRARY_DESCRIPTOR = LIBRARY_DESCRIPTOR
        self.SPOT_DESCRIPTOR = SPOT_DESCRIPTOR
    def factory(*args_, **kwargs_):
        if LibraryType.subclass:
            return LibraryType.subclass(*args_, **kwargs_)
        else:
            return LibraryType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DESIGN_DESCRIPTION(self): return self.DESIGN_DESCRIPTION
    def set_DESIGN_DESCRIPTION(self, DESIGN_DESCRIPTION): self.DESIGN_DESCRIPTION = DESIGN_DESCRIPTION
    def get_SAMPLE_DESCRIPTOR(self): return self.SAMPLE_DESCRIPTOR
    def set_SAMPLE_DESCRIPTOR(self, SAMPLE_DESCRIPTOR): self.SAMPLE_DESCRIPTOR = SAMPLE_DESCRIPTOR
    def get_LIBRARY_DESCRIPTOR(self): return self.LIBRARY_DESCRIPTOR
    def set_LIBRARY_DESCRIPTOR(self, LIBRARY_DESCRIPTOR): self.LIBRARY_DESCRIPTOR = LIBRARY_DESCRIPTOR
    def get_SPOT_DESCRIPTOR(self): return self.SPOT_DESCRIPTOR
    def set_SPOT_DESCRIPTOR(self, SPOT_DESCRIPTOR): self.SPOT_DESCRIPTOR = SPOT_DESCRIPTOR
    def hasContent_(self):
        if (
            self.DESIGN_DESCRIPTION is not None or
            self.SAMPLE_DESCRIPTOR is not None or
            self.LIBRARY_DESCRIPTOR is not None or
            self.SPOT_DESCRIPTOR is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LibraryType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LibraryType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LibraryType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LibraryType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LibraryType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DESIGN_DESCRIPTION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESIGN_DESCRIPTION>%s</%sDESIGN_DESCRIPTION>%s' % (namespace_, self.gds_format_string(quote_xml(self.DESIGN_DESCRIPTION).encode(ExternalEncoding), input_name='DESIGN_DESCRIPTION'), namespace_, eol_))
        if self.SAMPLE_DESCRIPTOR is not None:
            self.SAMPLE_DESCRIPTOR.export(outfile, level, namespace_, name_='SAMPLE_DESCRIPTOR', pretty_print=pretty_print)
        if self.LIBRARY_DESCRIPTOR is not None:
            self.LIBRARY_DESCRIPTOR.export(outfile, level, namespace_, name_='LIBRARY_DESCRIPTOR', pretty_print=pretty_print)
        if self.SPOT_DESCRIPTOR is not None:
            self.SPOT_DESCRIPTOR.export(outfile, level, namespace_, name_='SPOT_DESCRIPTOR', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LibraryType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DESIGN_DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESIGN_DESCRIPTION=%s,\n' % quote_python(self.DESIGN_DESCRIPTION).encode(ExternalEncoding))
        if self.SAMPLE_DESCRIPTOR is not None:
            showIndent(outfile, level)
            outfile.write('SAMPLE_DESCRIPTOR=model_.SampleDescriptorType(\n')
            self.SAMPLE_DESCRIPTOR.exportLiteral(outfile, level, name_='SAMPLE_DESCRIPTOR')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.LIBRARY_DESCRIPTOR is not None:
            showIndent(outfile, level)
            outfile.write('LIBRARY_DESCRIPTOR=model_.LibraryDescriptorType(\n')
            self.LIBRARY_DESCRIPTOR.exportLiteral(outfile, level, name_='LIBRARY_DESCRIPTOR')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.SPOT_DESCRIPTOR is not None:
            showIndent(outfile, level)
            outfile.write('SPOT_DESCRIPTOR=model_.SpotDescriptorType(\n')
            self.SPOT_DESCRIPTOR.exportLiteral(outfile, level, name_='SPOT_DESCRIPTOR')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DESIGN_DESCRIPTION':
            DESIGN_DESCRIPTION_ = child_.text
            DESIGN_DESCRIPTION_ = self.gds_validate_string(DESIGN_DESCRIPTION_, node, 'DESIGN_DESCRIPTION')
            self.DESIGN_DESCRIPTION = DESIGN_DESCRIPTION_
        elif nodeName_ == 'SAMPLE_DESCRIPTOR':
            obj_ = SampleDescriptorType.factory()
            obj_.build(child_)
            self.SAMPLE_DESCRIPTOR = obj_
            obj_.original_tagname_ = 'SAMPLE_DESCRIPTOR'
        elif nodeName_ == 'LIBRARY_DESCRIPTOR':
            obj_ = LibraryDescriptorType.factory()
            obj_.build(child_)
            self.LIBRARY_DESCRIPTOR = obj_
            obj_.original_tagname_ = 'LIBRARY_DESCRIPTOR'
        elif nodeName_ == 'SPOT_DESCRIPTOR':
            obj_ = SpotDescriptorType.factory()
            obj_.build(child_)
            self.SPOT_DESCRIPTOR = obj_
            obj_.original_tagname_ = 'SPOT_DESCRIPTOR'
# end class LibraryType


class ExperimentSetType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EXPERIMENT=None):
        self.original_tagname_ = None
        if EXPERIMENT is None:
            self.EXPERIMENT = []
        else:
            self.EXPERIMENT = EXPERIMENT
    def factory(*args_, **kwargs_):
        if ExperimentSetType.subclass:
            return ExperimentSetType.subclass(*args_, **kwargs_)
        else:
            return ExperimentSetType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EXPERIMENT(self): return self.EXPERIMENT
    def set_EXPERIMENT(self, EXPERIMENT): self.EXPERIMENT = EXPERIMENT
    def add_EXPERIMENT(self, value): self.EXPERIMENT.append(value)
    def insert_EXPERIMENT_at(self, index, value): self.EXPERIMENT.insert(index, value)
    def replace_EXPERIMENT_at(self, index, value): self.EXPERIMENT[index] = value
    def hasContent_(self):
        if (
            self.EXPERIMENT
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExperimentSetType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExperimentSetType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExperimentSetType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExperimentSetType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ExperimentSetType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EXPERIMENT_ in self.EXPERIMENT:
            EXPERIMENT_.export(outfile, level, namespace_, name_='EXPERIMENT', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ExperimentSetType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('EXPERIMENT=[\n')
        level += 1
        for EXPERIMENT_ in self.EXPERIMENT:
            showIndent(outfile, level)
            outfile.write('model_.ExperimentType(\n')
            EXPERIMENT_.exportLiteral(outfile, level, name_='ExperimentType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EXPERIMENT':
            obj_ = ExperimentType.factory()
            obj_.build(child_)
            self.EXPERIMENT.append(obj_)
            obj_.original_tagname_ = 'EXPERIMENT'
# end class ExperimentSetType


class ObjectType(GeneratedsSuper):
    """Submitter designated name for the object. The name must be unique
    within the submission account. The center name of the submitter.
    The center name of the broker. The object accession assigned by
    the archive."""
    subclass = None
    superclass = None
    def __init__(self, center_name=None, alias=None, broker_name=None, accession=None, IDENTIFIERS=None, extensiontype_=None):
        self.original_tagname_ = None
        self.center_name = _cast(None, center_name)
        self.alias = _cast(None, alias)
        self.broker_name = _cast(None, broker_name)
        self.accession = _cast(None, accession)
        self.IDENTIFIERS = IDENTIFIERS
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if ObjectType.subclass:
            return ObjectType.subclass(*args_, **kwargs_)
        else:
            return ObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IDENTIFIERS(self): return self.IDENTIFIERS
    def set_IDENTIFIERS(self, IDENTIFIERS): self.IDENTIFIERS = IDENTIFIERS
    def get_center_name(self): return self.center_name
    def set_center_name(self, center_name): self.center_name = center_name
    def get_alias(self): return self.alias
    def set_alias(self, alias): self.alias = alias
    def get_broker_name(self): return self.broker_name
    def set_broker_name(self, broker_name): self.broker_name = broker_name
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ObjectType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ObjectType'):
        if self.center_name is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            outfile.write(' center_name=%s' % (self.gds_format_string(quote_attrib(self.center_name).encode(ExternalEncoding), input_name='center_name'), ))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            outfile.write(' alias=%s' % (self.gds_format_string(quote_attrib(self.alias).encode(ExternalEncoding), input_name='alias'), ))
        if self.broker_name is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            outfile.write(' broker_name=%s' % (self.gds_format_string(quote_attrib(self.broker_name).encode(ExternalEncoding), input_name='broker_name'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='ObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.center_name is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            showIndent(outfile, level)
            outfile.write('center_name="%s",\n' % (self.center_name,))
        if self.alias is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            showIndent(outfile, level)
            outfile.write('alias="%s",\n' % (self.alias,))
        if self.broker_name is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            showIndent(outfile, level)
            outfile.write('broker_name="%s",\n' % (self.broker_name,))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IDENTIFIERS is not None:
            showIndent(outfile, level)
            outfile.write('IDENTIFIERS=model_.IdentifierType(\n')
            self.IDENTIFIERS.exportLiteral(outfile, level, name_='IDENTIFIERS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('center_name', node)
        if value is not None and 'center_name' not in already_processed:
            already_processed.add('center_name')
            self.center_name = value
        value = find_attr_value_('alias', node)
        if value is not None and 'alias' not in already_processed:
            already_processed.add('alias')
            self.alias = value
        value = find_attr_value_('broker_name', node)
        if value is not None and 'broker_name' not in already_processed:
            already_processed.add('broker_name')
            self.broker_name = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'
# end class ObjectType


class RefObjectType(GeneratedsSuper):
    """Identifies an object by name within the namespace defined by
    attribute "refcenter". The namespace of the attribute "refname".
    Identifies a record by its accession. The scope of resolution is
    the entire Archive."""
    subclass = None
    superclass = None
    def __init__(self, accession=None, refname=None, refcenter=None, IDENTIFIERS=None, extensiontype_=None):
        self.original_tagname_ = None
        self.accession = _cast(None, accession)
        self.refname = _cast(None, refname)
        self.refcenter = _cast(None, refcenter)
        self.IDENTIFIERS = IDENTIFIERS
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if RefObjectType.subclass:
            return RefObjectType.subclass(*args_, **kwargs_)
        else:
            return RefObjectType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_IDENTIFIERS(self): return self.IDENTIFIERS
    def set_IDENTIFIERS(self, IDENTIFIERS): self.IDENTIFIERS = IDENTIFIERS
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def get_refname(self): return self.refname
    def set_refname(self, refname): self.refname = refname
    def get_refcenter(self): return self.refcenter
    def set_refcenter(self, refcenter): self.refcenter = refcenter
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.IDENTIFIERS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RefObjectType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RefObjectType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RefObjectType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RefObjectType'):
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding), input_name='refname'), ))
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            outfile.write(' refcenter=%s' % (self.gds_format_string(quote_attrib(self.refcenter).encode(ExternalEncoding), input_name='refcenter'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='RefObjectType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.IDENTIFIERS is not None:
            self.IDENTIFIERS.export(outfile, level, namespace_, name_='IDENTIFIERS', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='RefObjectType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            showIndent(outfile, level)
            outfile.write('refname="%s",\n' % (self.refname,))
        if self.refcenter is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            showIndent(outfile, level)
            outfile.write('refcenter="%s",\n' % (self.refcenter,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.IDENTIFIERS is not None:
            showIndent(outfile, level)
            outfile.write('IDENTIFIERS=model_.IdentifierType(\n')
            self.IDENTIFIERS.exportLiteral(outfile, level, name_='IDENTIFIERS')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('refcenter', node)
        if value is not None and 'refcenter' not in already_processed:
            already_processed.add('refcenter')
            self.refcenter = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'IDENTIFIERS':
            obj_ = IdentifierType.factory()
            obj_.build(child_)
            self.IDENTIFIERS = obj_
            obj_.original_tagname_ = 'IDENTIFIERS'
# end class RefObjectType


class NameType(GeneratedsSuper):
    """Alternative/explanatory description of the same object/identifier."""
    subclass = None
    superclass = None
    def __init__(self, label=None, valueOf_=None, extensiontype_=None):
        self.original_tagname_ = None
        self.label = _cast(None, label)
        self.valueOf_ = valueOf_
        self.extensiontype_ = extensiontype_
    def factory(*args_, **kwargs_):
        if NameType.subclass:
            return NameType.subclass(*args_, **kwargs_)
        else:
            return NameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def get_extensiontype_(self): return self.extensiontype_
    def set_extensiontype_(self, extensiontype_): self.extensiontype_ = extensiontype_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='NameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='NameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='NameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='NameType'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.extensiontype_ is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            outfile.write(' xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"')
            outfile.write(' xsi:type="%s"' % self.extensiontype_)
    def exportChildren(self, outfile, level, namespace_='', name_='NameType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='NameType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            showIndent(outfile, level)
            outfile.write('label="%s",\n' % (self.label,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('xsi:type', node)
        if value is not None and 'xsi:type' not in already_processed:
            already_processed.add('xsi:type')
            self.extensiontype_ = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class NameType


class QualifiedNameType(NameType):
    """A string value that constrains the domain of named identifiers
    (namespace)."""
    subclass = None
    superclass = NameType
    def __init__(self, label=None, namespace=None, valueOf_=None):
        self.original_tagname_ = None
        super(QualifiedNameType, self).__init__(label, valueOf_, )
        self.namespace = _cast(None, namespace)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if QualifiedNameType.subclass:
            return QualifiedNameType.subclass(*args_, **kwargs_)
        else:
            return QualifiedNameType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_namespace(self): return self.namespace
    def set_namespace(self, namespace): self.namespace = namespace
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_ or
            super(QualifiedNameType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='QualifiedNameType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='QualifiedNameType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='QualifiedNameType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='QualifiedNameType'):
        super(QualifiedNameType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='QualifiedNameType')
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            outfile.write(' namespace=%s' % (self.gds_format_string(quote_attrib(self.namespace).encode(ExternalEncoding), input_name='namespace'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='QualifiedNameType', fromsubclass_=False, pretty_print=True):
        super(QualifiedNameType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        pass
    def exportLiteral(self, outfile, level, name_='QualifiedNameType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.namespace is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            showIndent(outfile, level)
            outfile.write('namespace="%s",\n' % (self.namespace,))
        super(QualifiedNameType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(QualifiedNameType, self).exportLiteralChildren(outfile, level, name_)
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('namespace', node)
        if value is not None and 'namespace' not in already_processed:
            already_processed.add('namespace')
            self.namespace = value
        super(QualifiedNameType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class QualifiedNameType


class IdentifierType(GeneratedsSuper):
    """Set of record identifiers."""
    subclass = None
    superclass = None
    def __init__(self, PRIMARY_ID=None, SECONDARY_ID=None, EXTERNAL_ID=None, SUBMITTER_ID=None, UUID=None):
        self.original_tagname_ = None
        self.PRIMARY_ID = PRIMARY_ID
        if SECONDARY_ID is None:
            self.SECONDARY_ID = []
        else:
            self.SECONDARY_ID = SECONDARY_ID
        if EXTERNAL_ID is None:
            self.EXTERNAL_ID = []
        else:
            self.EXTERNAL_ID = EXTERNAL_ID
        self.SUBMITTER_ID = SUBMITTER_ID
        if UUID is None:
            self.UUID = []
        else:
            self.UUID = UUID
    def factory(*args_, **kwargs_):
        if IdentifierType.subclass:
            return IdentifierType.subclass(*args_, **kwargs_)
        else:
            return IdentifierType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PRIMARY_ID(self): return self.PRIMARY_ID
    def set_PRIMARY_ID(self, PRIMARY_ID): self.PRIMARY_ID = PRIMARY_ID
    def get_SECONDARY_ID(self): return self.SECONDARY_ID
    def set_SECONDARY_ID(self, SECONDARY_ID): self.SECONDARY_ID = SECONDARY_ID
    def add_SECONDARY_ID(self, value): self.SECONDARY_ID.append(value)
    def insert_SECONDARY_ID_at(self, index, value): self.SECONDARY_ID.insert(index, value)
    def replace_SECONDARY_ID_at(self, index, value): self.SECONDARY_ID[index] = value
    def get_EXTERNAL_ID(self): return self.EXTERNAL_ID
    def set_EXTERNAL_ID(self, EXTERNAL_ID): self.EXTERNAL_ID = EXTERNAL_ID
    def add_EXTERNAL_ID(self, value): self.EXTERNAL_ID.append(value)
    def insert_EXTERNAL_ID_at(self, index, value): self.EXTERNAL_ID.insert(index, value)
    def replace_EXTERNAL_ID_at(self, index, value): self.EXTERNAL_ID[index] = value
    def get_SUBMITTER_ID(self): return self.SUBMITTER_ID
    def set_SUBMITTER_ID(self, SUBMITTER_ID): self.SUBMITTER_ID = SUBMITTER_ID
    def get_UUID(self): return self.UUID
    def set_UUID(self, UUID): self.UUID = UUID
    def add_UUID(self, value): self.UUID.append(value)
    def insert_UUID_at(self, index, value): self.UUID.insert(index, value)
    def replace_UUID_at(self, index, value): self.UUID[index] = value
    def hasContent_(self):
        if (
            self.PRIMARY_ID is not None or
            self.SECONDARY_ID or
            self.EXTERNAL_ID or
            self.SUBMITTER_ID is not None or
            self.UUID
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='IdentifierType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='IdentifierType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='IdentifierType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='IdentifierType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='IdentifierType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PRIMARY_ID is not None:
            self.PRIMARY_ID.export(outfile, level, namespace_, name_='PRIMARY_ID', pretty_print=pretty_print)
        for SECONDARY_ID_ in self.SECONDARY_ID:
            SECONDARY_ID_.export(outfile, level, namespace_, name_='SECONDARY_ID', pretty_print=pretty_print)
        for EXTERNAL_ID_ in self.EXTERNAL_ID:
            EXTERNAL_ID_.export(outfile, level, namespace_, name_='EXTERNAL_ID', pretty_print=pretty_print)
        if self.SUBMITTER_ID is not None:
            self.SUBMITTER_ID.export(outfile, level, namespace_, name_='SUBMITTER_ID', pretty_print=pretty_print)
        for UUID_ in self.UUID:
            UUID_.export(outfile, level, namespace_, name_='UUID', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='IdentifierType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PRIMARY_ID is not None:
            showIndent(outfile, level)
            outfile.write('PRIMARY_ID=model_.NameType(\n')
            self.PRIMARY_ID.exportLiteral(outfile, level, name_='PRIMARY_ID')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SECONDARY_ID=[\n')
        level += 1
        for SECONDARY_ID_ in self.SECONDARY_ID:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            SECONDARY_ID_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        showIndent(outfile, level)
        outfile.write('EXTERNAL_ID=[\n')
        level += 1
        for EXTERNAL_ID_ in self.EXTERNAL_ID:
            showIndent(outfile, level)
            outfile.write('model_.QualifiedNameType(\n')
            EXTERNAL_ID_.exportLiteral(outfile, level, name_='QualifiedNameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.SUBMITTER_ID is not None:
            showIndent(outfile, level)
            outfile.write('SUBMITTER_ID=model_.QualifiedNameType(\n')
            self.SUBMITTER_ID.exportLiteral(outfile, level, name_='SUBMITTER_ID')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('UUID=[\n')
        level += 1
        for UUID_ in self.UUID:
            showIndent(outfile, level)
            outfile.write('model_.NameType(\n')
            UUID_.exportLiteral(outfile, level, name_='NameType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PRIMARY_ID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.PRIMARY_ID = obj_
            obj_.original_tagname_ = 'PRIMARY_ID'
        elif nodeName_ == 'SECONDARY_ID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.SECONDARY_ID.append(obj_)
            obj_.original_tagname_ = 'SECONDARY_ID'
        elif nodeName_ == 'EXTERNAL_ID':
            obj_ = QualifiedNameType.factory()
            obj_.build(child_)
            self.EXTERNAL_ID.append(obj_)
            obj_.original_tagname_ = 'EXTERNAL_ID'
        elif nodeName_ == 'SUBMITTER_ID':
            obj_ = QualifiedNameType.factory()
            obj_.build(child_)
            self.SUBMITTER_ID = obj_
            obj_.original_tagname_ = 'SUBMITTER_ID'
        elif nodeName_ == 'UUID':
            class_obj_ = self.get_class_obj_(child_, NameType)
            obj_ = class_obj_.factory()
            obj_.build(child_)
            self.UUID.append(obj_)
            obj_.original_tagname_ = 'UUID'
# end class IdentifierType


class XRefType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DB=None, ID=None, LABEL=None):
        self.original_tagname_ = None
        self.DB = DB
        self.ID = ID
        self.LABEL = LABEL
    def factory(*args_, **kwargs_):
        if XRefType.subclass:
            return XRefType.subclass(*args_, **kwargs_)
        else:
            return XRefType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DB(self): return self.DB
    def set_DB(self, DB): self.DB = DB
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def hasContent_(self):
        if (
            self.DB is not None or
            self.ID is not None or
            self.LABEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='XRefType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='XRefType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='XRefType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='XRefType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='XRefType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB>%s</%sDB>%s' % (namespace_, self.gds_format_string(quote_xml(self.DB).encode(ExternalEncoding), input_name='DB'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_string(quote_xml(self.ID).encode(ExternalEncoding), input_name='ID'), namespace_, eol_))
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='XRefType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DB is not None:
            showIndent(outfile, level)
            outfile.write('DB=%s,\n' % quote_python(self.DB).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%s,\n' % quote_python(self.ID).encode(ExternalEncoding))
        if self.LABEL is not None:
            showIndent(outfile, level)
            outfile.write('LABEL=%s,\n' % quote_python(self.LABEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DB':
            DB_ = child_.text
            DB_ = self.gds_validate_string(DB_, node, 'DB')
            self.DB = DB_
        elif nodeName_ == 'ID':
            ID_ = child_.text
            ID_ = self.gds_validate_string(ID_, node, 'ID')
            self.ID = ID_
        elif nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
# end class XRefType


class URLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL
    def factory(*args_, **kwargs_):
        if URLType.subclass:
            return URLType.subclass(*args_, **kwargs_)
        else:
            return URLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def hasContent_(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='URLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URLType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='URLType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LABEL is not None:
            showIndent(outfile, level)
            outfile.write('LABEL=%s,\n' % quote_python(self.LABEL).encode(ExternalEncoding))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URLType


class AttributeType(GeneratedsSuper):
    """Reusable attributes to encode tag-value pairs with optional units."""
    subclass = None
    superclass = None
    def __init__(self, TAG=None, VALUE=None, UNITS=None):
        self.original_tagname_ = None
        self.TAG = TAG
        self.VALUE = VALUE
        self.UNITS = UNITS
    def factory(*args_, **kwargs_):
        if AttributeType.subclass:
            return AttributeType.subclass(*args_, **kwargs_)
        else:
            return AttributeType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TAG(self): return self.TAG
    def set_TAG(self, TAG): self.TAG = TAG
    def get_VALUE(self): return self.VALUE
    def set_VALUE(self, VALUE): self.VALUE = VALUE
    def get_UNITS(self): return self.UNITS
    def set_UNITS(self, UNITS): self.UNITS = UNITS
    def hasContent_(self):
        if (
            self.TAG is not None or
            self.VALUE is not None or
            self.UNITS is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='AttributeType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='AttributeType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='AttributeType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='AttributeType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='AttributeType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TAG is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTAG>%s</%sTAG>%s' % (namespace_, self.gds_format_string(quote_xml(self.TAG).encode(ExternalEncoding), input_name='TAG'), namespace_, eol_))
        if self.VALUE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVALUE>%s</%sVALUE>%s' % (namespace_, self.gds_format_string(quote_xml(self.VALUE).encode(ExternalEncoding), input_name='VALUE'), namespace_, eol_))
        if self.UNITS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sUNITS>%s</%sUNITS>%s' % (namespace_, self.gds_format_string(quote_xml(self.UNITS).encode(ExternalEncoding), input_name='UNITS'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='AttributeType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.TAG is not None:
            showIndent(outfile, level)
            outfile.write('TAG=%s,\n' % quote_python(self.TAG).encode(ExternalEncoding))
        if self.VALUE is not None:
            showIndent(outfile, level)
            outfile.write('VALUE=%s,\n' % quote_python(self.VALUE).encode(ExternalEncoding))
        if self.UNITS is not None:
            showIndent(outfile, level)
            outfile.write('UNITS=%s,\n' % quote_python(self.UNITS).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TAG':
            TAG_ = child_.text
            TAG_ = self.gds_validate_string(TAG_, node, 'TAG')
            self.TAG = TAG_
        elif nodeName_ == 'VALUE':
            VALUE_ = child_.text
            VALUE_ = self.gds_validate_string(VALUE_, node, 'VALUE')
            self.VALUE = VALUE_
        elif nodeName_ == 'UNITS':
            UNITS_ = child_.text
            UNITS_ = self.gds_validate_string(UNITS_, node, 'UNITS')
            self.UNITS = UNITS_
# end class AttributeType


class LinkType(GeneratedsSuper):
    """Reusable external links type to encode URL links, Entrez links, and
    db_xref links."""
    subclass = None
    superclass = None
    def __init__(self, URL_LINK=None, XREF_LINK=None, ENTREZ_LINK=None):
        self.original_tagname_ = None
        self.URL_LINK = URL_LINK
        self.XREF_LINK = XREF_LINK
        self.ENTREZ_LINK = ENTREZ_LINK
    def factory(*args_, **kwargs_):
        if LinkType.subclass:
            return LinkType.subclass(*args_, **kwargs_)
        else:
            return LinkType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_URL_LINK(self): return self.URL_LINK
    def set_URL_LINK(self, URL_LINK): self.URL_LINK = URL_LINK
    def get_XREF_LINK(self): return self.XREF_LINK
    def set_XREF_LINK(self, XREF_LINK): self.XREF_LINK = XREF_LINK
    def get_ENTREZ_LINK(self): return self.ENTREZ_LINK
    def set_ENTREZ_LINK(self, ENTREZ_LINK): self.ENTREZ_LINK = ENTREZ_LINK
    def hasContent_(self):
        if (
            self.URL_LINK is not None or
            self.XREF_LINK is not None or
            self.ENTREZ_LINK is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LinkType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LinkType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LinkType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LinkType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LinkType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.URL_LINK is not None:
            self.URL_LINK.export(outfile, level, namespace_, name_='URL_LINK', pretty_print=pretty_print)
        if self.XREF_LINK is not None:
            self.XREF_LINK.export(outfile, level, namespace_, name_='XREF_LINK', pretty_print=pretty_print)
        if self.ENTREZ_LINK is not None:
            self.ENTREZ_LINK.export(outfile, level, namespace_, name_='ENTREZ_LINK', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LinkType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.URL_LINK is not None:
            showIndent(outfile, level)
            outfile.write('URL_LINK=model_.URL_LINKType(\n')
            self.URL_LINK.exportLiteral(outfile, level, name_='URL_LINK')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.XREF_LINK is not None:
            showIndent(outfile, level)
            outfile.write('XREF_LINK=model_.XRefType(\n')
            self.XREF_LINK.exportLiteral(outfile, level, name_='XREF_LINK')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ENTREZ_LINK is not None:
            showIndent(outfile, level)
            outfile.write('ENTREZ_LINK=model_.ENTREZ_LINKType(\n')
            self.ENTREZ_LINK.exportLiteral(outfile, level, name_='ENTREZ_LINK')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'URL_LINK':
            obj_ = URL_LINKType.factory()
            obj_.build(child_)
            self.URL_LINK = obj_
            obj_.original_tagname_ = 'URL_LINK'
        elif nodeName_ == 'XREF_LINK':
            obj_ = XRefType.factory()
            obj_.build(child_)
            self.XREF_LINK = obj_
            obj_.original_tagname_ = 'XREF_LINK'
        elif nodeName_ == 'ENTREZ_LINK':
            obj_ = ENTREZ_LINKType.factory()
            obj_.build(child_)
            self.ENTREZ_LINK = obj_
            obj_.original_tagname_ = 'ENTREZ_LINK'
# end class LinkType


class SpotDescriptorType(GeneratedsSuper):
    """The SPOT_DESCRIPTOR specifies how to decode the individual reads of
    interest from the monolithic spot sequence. The spot descriptor
    contains aspects of the experimental design, platform, and
    processing information. There will be two methods of
    specification: one will be an index into a table of typical
    decodings, the other being an exact specification."""
    subclass = None
    superclass = None
    def __init__(self, SPOT_DECODE_SPEC=None):
        self.original_tagname_ = None
        self.SPOT_DECODE_SPEC = SPOT_DECODE_SPEC
    def factory(*args_, **kwargs_):
        if SpotDescriptorType.subclass:
            return SpotDescriptorType.subclass(*args_, **kwargs_)
        else:
            return SpotDescriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SPOT_DECODE_SPEC(self): return self.SPOT_DECODE_SPEC
    def set_SPOT_DECODE_SPEC(self, SPOT_DECODE_SPEC): self.SPOT_DECODE_SPEC = SPOT_DECODE_SPEC
    def hasContent_(self):
        if (
            self.SPOT_DECODE_SPEC is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SpotDescriptorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SpotDescriptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SpotDescriptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SpotDescriptorType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SpotDescriptorType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SPOT_DECODE_SPEC is not None:
            self.SPOT_DECODE_SPEC.export(outfile, level, namespace_, name_='SPOT_DECODE_SPEC', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SpotDescriptorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SPOT_DECODE_SPEC is not None:
            showIndent(outfile, level)
            outfile.write('SPOT_DECODE_SPEC=model_.SPOT_DECODE_SPECType(\n')
            self.SPOT_DECODE_SPEC.exportLiteral(outfile, level, name_='SPOT_DECODE_SPEC')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SPOT_DECODE_SPEC':
            obj_ = SPOT_DECODE_SPECType.factory()
            obj_.build(child_)
            self.SPOT_DECODE_SPEC = obj_
            obj_.original_tagname_ = 'SPOT_DECODE_SPEC'
# end class SpotDescriptorType


class PlatformType(GeneratedsSuper):
    """The PLATFORM record selects which sequencing platform and platform-
    specific runtime parameters. This will be determined by the
    Center."""
    subclass = None
    superclass = None
    def __init__(self, LS454=None, ILLUMINA=None, HELICOS=None, ABI_SOLID=None, COMPLETE_GENOMICS=None, BGISEQ=None, OXFORD_NANOPORE=None, PACBIO_SMRT=None, ION_TORRENT=None, CAPILLARY=None):
        self.original_tagname_ = None
        self.LS454 = LS454
        self.ILLUMINA = ILLUMINA
        self.HELICOS = HELICOS
        self.ABI_SOLID = ABI_SOLID
        self.COMPLETE_GENOMICS = COMPLETE_GENOMICS
        self.BGISEQ = BGISEQ
        self.OXFORD_NANOPORE = OXFORD_NANOPORE
        self.PACBIO_SMRT = PACBIO_SMRT
        self.ION_TORRENT = ION_TORRENT
        self.CAPILLARY = CAPILLARY
    def factory(*args_, **kwargs_):
        if PlatformType.subclass:
            return PlatformType.subclass(*args_, **kwargs_)
        else:
            return PlatformType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LS454(self): return self.LS454
    def set_LS454(self, LS454): self.LS454 = LS454
    def get_ILLUMINA(self): return self.ILLUMINA
    def set_ILLUMINA(self, ILLUMINA): self.ILLUMINA = ILLUMINA
    def get_HELICOS(self): return self.HELICOS
    def set_HELICOS(self, HELICOS): self.HELICOS = HELICOS
    def get_ABI_SOLID(self): return self.ABI_SOLID
    def set_ABI_SOLID(self, ABI_SOLID): self.ABI_SOLID = ABI_SOLID
    def get_COMPLETE_GENOMICS(self): return self.COMPLETE_GENOMICS
    def set_COMPLETE_GENOMICS(self, COMPLETE_GENOMICS): self.COMPLETE_GENOMICS = COMPLETE_GENOMICS
    def get_BGISEQ(self): return self.BGISEQ
    def set_BGISEQ(self, BGISEQ): self.BGISEQ = BGISEQ
    def get_OXFORD_NANOPORE(self): return self.OXFORD_NANOPORE
    def set_OXFORD_NANOPORE(self, OXFORD_NANOPORE): self.OXFORD_NANOPORE = OXFORD_NANOPORE
    def get_PACBIO_SMRT(self): return self.PACBIO_SMRT
    def set_PACBIO_SMRT(self, PACBIO_SMRT): self.PACBIO_SMRT = PACBIO_SMRT
    def get_ION_TORRENT(self): return self.ION_TORRENT
    def set_ION_TORRENT(self, ION_TORRENT): self.ION_TORRENT = ION_TORRENT
    def get_CAPILLARY(self): return self.CAPILLARY
    def set_CAPILLARY(self, CAPILLARY): self.CAPILLARY = CAPILLARY
    def hasContent_(self):
        if (
            self.LS454 is not None or
            self.ILLUMINA is not None or
            self.HELICOS is not None or
            self.ABI_SOLID is not None or
            self.COMPLETE_GENOMICS is not None or
            self.BGISEQ is not None or
            self.OXFORD_NANOPORE is not None or
            self.PACBIO_SMRT is not None or
            self.ION_TORRENT is not None or
            self.CAPILLARY is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PlatformType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PlatformType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PlatformType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PlatformType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PlatformType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LS454 is not None:
            self.LS454.export(outfile, level, namespace_, name_='LS454', pretty_print=pretty_print)
        if self.ILLUMINA is not None:
            self.ILLUMINA.export(outfile, level, namespace_, name_='ILLUMINA', pretty_print=pretty_print)
        if self.HELICOS is not None:
            self.HELICOS.export(outfile, level, namespace_, name_='HELICOS', pretty_print=pretty_print)
        if self.ABI_SOLID is not None:
            self.ABI_SOLID.export(outfile, level, namespace_, name_='ABI_SOLID', pretty_print=pretty_print)
        if self.COMPLETE_GENOMICS is not None:
            self.COMPLETE_GENOMICS.export(outfile, level, namespace_, name_='COMPLETE_GENOMICS', pretty_print=pretty_print)
        if self.BGISEQ is not None:
            self.BGISEQ.export(outfile, level, namespace_, name_='BGISEQ', pretty_print=pretty_print)
        if self.OXFORD_NANOPORE is not None:
            self.OXFORD_NANOPORE.export(outfile, level, namespace_, name_='OXFORD_NANOPORE', pretty_print=pretty_print)
        if self.PACBIO_SMRT is not None:
            self.PACBIO_SMRT.export(outfile, level, namespace_, name_='PACBIO_SMRT', pretty_print=pretty_print)
        if self.ION_TORRENT is not None:
            self.ION_TORRENT.export(outfile, level, namespace_, name_='ION_TORRENT', pretty_print=pretty_print)
        if self.CAPILLARY is not None:
            self.CAPILLARY.export(outfile, level, namespace_, name_='CAPILLARY', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PlatformType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LS454 is not None:
            showIndent(outfile, level)
            outfile.write('LS454=model_.LS454Type(\n')
            self.LS454.exportLiteral(outfile, level, name_='LS454')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ILLUMINA is not None:
            showIndent(outfile, level)
            outfile.write('ILLUMINA=model_.ILLUMINAType(\n')
            self.ILLUMINA.exportLiteral(outfile, level, name_='ILLUMINA')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.HELICOS is not None:
            showIndent(outfile, level)
            outfile.write('HELICOS=model_.HELICOSType(\n')
            self.HELICOS.exportLiteral(outfile, level, name_='HELICOS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ABI_SOLID is not None:
            showIndent(outfile, level)
            outfile.write('ABI_SOLID=model_.ABI_SOLIDType(\n')
            self.ABI_SOLID.exportLiteral(outfile, level, name_='ABI_SOLID')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.COMPLETE_GENOMICS is not None:
            showIndent(outfile, level)
            outfile.write('COMPLETE_GENOMICS=model_.COMPLETE_GENOMICSType(\n')
            self.COMPLETE_GENOMICS.exportLiteral(outfile, level, name_='COMPLETE_GENOMICS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BGISEQ is not None:
            showIndent(outfile, level)
            outfile.write('BGISEQ=model_.BGISEQType(\n')
            self.BGISEQ.exportLiteral(outfile, level, name_='BGISEQ')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.OXFORD_NANOPORE is not None:
            showIndent(outfile, level)
            outfile.write('OXFORD_NANOPORE=model_.OXFORD_NANOPOREType(\n')
            self.OXFORD_NANOPORE.exportLiteral(outfile, level, name_='OXFORD_NANOPORE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PACBIO_SMRT is not None:
            showIndent(outfile, level)
            outfile.write('PACBIO_SMRT=model_.PACBIO_SMRTType(\n')
            self.PACBIO_SMRT.exportLiteral(outfile, level, name_='PACBIO_SMRT')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.ION_TORRENT is not None:
            showIndent(outfile, level)
            outfile.write('ION_TORRENT=model_.ION_TORRENTType(\n')
            self.ION_TORRENT.exportLiteral(outfile, level, name_='ION_TORRENT')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CAPILLARY is not None:
            showIndent(outfile, level)
            outfile.write('CAPILLARY=model_.CAPILLARYType(\n')
            self.CAPILLARY.exportLiteral(outfile, level, name_='CAPILLARY')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LS454':
            obj_ = LS454Type.factory()
            obj_.build(child_)
            self.LS454 = obj_
            obj_.original_tagname_ = 'LS454'
        elif nodeName_ == 'ILLUMINA':
            obj_ = ILLUMINAType.factory()
            obj_.build(child_)
            self.ILLUMINA = obj_
            obj_.original_tagname_ = 'ILLUMINA'
        elif nodeName_ == 'HELICOS':
            obj_ = HELICOSType.factory()
            obj_.build(child_)
            self.HELICOS = obj_
            obj_.original_tagname_ = 'HELICOS'
        elif nodeName_ == 'ABI_SOLID':
            obj_ = ABI_SOLIDType.factory()
            obj_.build(child_)
            self.ABI_SOLID = obj_
            obj_.original_tagname_ = 'ABI_SOLID'
        elif nodeName_ == 'COMPLETE_GENOMICS':
            obj_ = COMPLETE_GENOMICSType.factory()
            obj_.build(child_)
            self.COMPLETE_GENOMICS = obj_
            obj_.original_tagname_ = 'COMPLETE_GENOMICS'
        elif nodeName_ == 'BGISEQ':
            obj_ = BGISEQType.factory()
            obj_.build(child_)
            self.BGISEQ = obj_
            obj_.original_tagname_ = 'BGISEQ'
        elif nodeName_ == 'OXFORD_NANOPORE':
            obj_ = OXFORD_NANOPOREType.factory()
            obj_.build(child_)
            self.OXFORD_NANOPORE = obj_
            obj_.original_tagname_ = 'OXFORD_NANOPORE'
        elif nodeName_ == 'PACBIO_SMRT':
            obj_ = PACBIO_SMRTType.factory()
            obj_.build(child_)
            self.PACBIO_SMRT = obj_
            obj_.original_tagname_ = 'PACBIO_SMRT'
        elif nodeName_ == 'ION_TORRENT':
            obj_ = ION_TORRENTType.factory()
            obj_.build(child_)
            self.ION_TORRENT = obj_
            obj_.original_tagname_ = 'ION_TORRENT'
        elif nodeName_ == 'CAPILLARY':
            obj_ = CAPILLARYType.factory()
            obj_.build(child_)
            self.CAPILLARY = obj_
            obj_.original_tagname_ = 'CAPILLARY'
# end class PlatformType


class SequencingDirectivesType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SAMPLE_DEMUX_DIRECTIVE=None):
        self.original_tagname_ = None
        self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE
        self.validate_SAMPLE_DEMUX_DIRECTIVEType(self.SAMPLE_DEMUX_DIRECTIVE)
    def factory(*args_, **kwargs_):
        if SequencingDirectivesType.subclass:
            return SequencingDirectivesType.subclass(*args_, **kwargs_)
        else:
            return SequencingDirectivesType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SAMPLE_DEMUX_DIRECTIVE(self): return self.SAMPLE_DEMUX_DIRECTIVE
    def set_SAMPLE_DEMUX_DIRECTIVE(self, SAMPLE_DEMUX_DIRECTIVE): self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE
    def validate_SAMPLE_DEMUX_DIRECTIVEType(self, value):
        # Validate type SAMPLE_DEMUX_DIRECTIVEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['leave_as_pool', 'submitter_demultiplexed']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on SAMPLE_DEMUX_DIRECTIVEType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.SAMPLE_DEMUX_DIRECTIVE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SequencingDirectivesType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SequencingDirectivesType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SequencingDirectivesType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SequencingDirectivesType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SequencingDirectivesType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SAMPLE_DEMUX_DIRECTIVE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSAMPLE_DEMUX_DIRECTIVE>%s</%sSAMPLE_DEMUX_DIRECTIVE>%s' % (namespace_, self.gds_format_string(quote_xml(self.SAMPLE_DEMUX_DIRECTIVE).encode(ExternalEncoding), input_name='SAMPLE_DEMUX_DIRECTIVE'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='SequencingDirectivesType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SAMPLE_DEMUX_DIRECTIVE is not None:
            showIndent(outfile, level)
            outfile.write('SAMPLE_DEMUX_DIRECTIVE=%s,\n' % quote_python(self.SAMPLE_DEMUX_DIRECTIVE).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SAMPLE_DEMUX_DIRECTIVE':
            SAMPLE_DEMUX_DIRECTIVE_ = child_.text
            SAMPLE_DEMUX_DIRECTIVE_ = self.gds_validate_string(SAMPLE_DEMUX_DIRECTIVE_, node, 'SAMPLE_DEMUX_DIRECTIVE')
            self.SAMPLE_DEMUX_DIRECTIVE = SAMPLE_DEMUX_DIRECTIVE_
            # validate type SAMPLE_DEMUX_DIRECTIVEType
            self.validate_SAMPLE_DEMUX_DIRECTIVEType(self.SAMPLE_DEMUX_DIRECTIVE)
# end class SequencingDirectivesType


class PipelineType(GeneratedsSuper):
    """The PipelineType identifies the sequence or tree of actions to
    process the sequencing data."""
    subclass = None
    superclass = None
    def __init__(self, PIPE_SECTION=None):
        self.original_tagname_ = None
        if PIPE_SECTION is None:
            self.PIPE_SECTION = []
        else:
            self.PIPE_SECTION = PIPE_SECTION
    def factory(*args_, **kwargs_):
        if PipelineType.subclass:
            return PipelineType.subclass(*args_, **kwargs_)
        else:
            return PipelineType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PIPE_SECTION(self): return self.PIPE_SECTION
    def set_PIPE_SECTION(self, PIPE_SECTION): self.PIPE_SECTION = PIPE_SECTION
    def add_PIPE_SECTION(self, value): self.PIPE_SECTION.append(value)
    def insert_PIPE_SECTION_at(self, index, value): self.PIPE_SECTION.insert(index, value)
    def replace_PIPE_SECTION_at(self, index, value): self.PIPE_SECTION[index] = value
    def hasContent_(self):
        if (
            self.PIPE_SECTION
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PipelineType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PipelineType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PipelineType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PipelineType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PipelineType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for PIPE_SECTION_ in self.PIPE_SECTION:
            PIPE_SECTION_.export(outfile, level, namespace_, name_='PIPE_SECTION', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PipelineType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('PIPE_SECTION=[\n')
        level += 1
        for PIPE_SECTION_ in self.PIPE_SECTION:
            showIndent(outfile, level)
            outfile.write('model_.PIPE_SECTIONType(\n')
            PIPE_SECTION_.exportLiteral(outfile, level, name_='PIPE_SECTIONType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PIPE_SECTION':
            obj_ = PIPE_SECTIONType.factory()
            obj_.build(child_)
            self.PIPE_SECTION.append(obj_)
            obj_.original_tagname_ = 'PIPE_SECTION'
# end class PipelineType


class ReferenceAssemblyType(GeneratedsSuper):
    """Reference assembly details."""
    subclass = None
    superclass = None
    def __init__(self, STANDARD=None, CUSTOM=None):
        self.original_tagname_ = None
        self.STANDARD = STANDARD
        self.CUSTOM = CUSTOM
    def factory(*args_, **kwargs_):
        if ReferenceAssemblyType.subclass:
            return ReferenceAssemblyType.subclass(*args_, **kwargs_)
        else:
            return ReferenceAssemblyType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STANDARD(self): return self.STANDARD
    def set_STANDARD(self, STANDARD): self.STANDARD = STANDARD
    def get_CUSTOM(self): return self.CUSTOM
    def set_CUSTOM(self, CUSTOM): self.CUSTOM = CUSTOM
    def hasContent_(self):
        if (
            self.STANDARD is not None or
            self.CUSTOM is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceAssemblyType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceAssemblyType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceAssemblyType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceAssemblyType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceAssemblyType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STANDARD is not None:
            self.STANDARD.export(outfile, level, namespace_, name_='STANDARD', pretty_print=pretty_print)
        if self.CUSTOM is not None:
            self.CUSTOM.export(outfile, level, namespace_, name_='CUSTOM', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceAssemblyType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.STANDARD is not None:
            showIndent(outfile, level)
            outfile.write('STANDARD=model_.STANDARDType(\n')
            self.STANDARD.exportLiteral(outfile, level, name_='STANDARD')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.CUSTOM is not None:
            showIndent(outfile, level)
            outfile.write('CUSTOM=model_.CUSTOMType(\n')
            self.CUSTOM.exportLiteral(outfile, level, name_='CUSTOM')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STANDARD':
            obj_ = STANDARDType.factory()
            obj_.build(child_)
            self.STANDARD = obj_
            obj_.original_tagname_ = 'STANDARD'
        elif nodeName_ == 'CUSTOM':
            obj_ = CUSTOMType.factory()
            obj_.build(child_)
            self.CUSTOM = obj_
            obj_.original_tagname_ = 'CUSTOM'
# end class ReferenceAssemblyType


class ReferenceSequenceType(GeneratedsSuper):
    """Reference assembly and sequence details."""
    subclass = None
    superclass = None
    def __init__(self, ASSEMBLY=None, SEQUENCE=None):
        self.original_tagname_ = None
        self.ASSEMBLY = ASSEMBLY
        if SEQUENCE is None:
            self.SEQUENCE = []
        else:
            self.SEQUENCE = SEQUENCE
    def factory(*args_, **kwargs_):
        if ReferenceSequenceType.subclass:
            return ReferenceSequenceType.subclass(*args_, **kwargs_)
        else:
            return ReferenceSequenceType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_ASSEMBLY(self): return self.ASSEMBLY
    def set_ASSEMBLY(self, ASSEMBLY): self.ASSEMBLY = ASSEMBLY
    def get_SEQUENCE(self): return self.SEQUENCE
    def set_SEQUENCE(self, SEQUENCE): self.SEQUENCE = SEQUENCE
    def add_SEQUENCE(self, value): self.SEQUENCE.append(value)
    def insert_SEQUENCE_at(self, index, value): self.SEQUENCE.insert(index, value)
    def replace_SEQUENCE_at(self, index, value): self.SEQUENCE[index] = value
    def hasContent_(self):
        if (
            self.ASSEMBLY is not None or
            self.SEQUENCE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ReferenceSequenceType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ReferenceSequenceType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ReferenceSequenceType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ReferenceSequenceType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ReferenceSequenceType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.ASSEMBLY is not None:
            self.ASSEMBLY.export(outfile, level, namespace_, name_='ASSEMBLY', pretty_print=pretty_print)
        for SEQUENCE_ in self.SEQUENCE:
            SEQUENCE_.export(outfile, level, namespace_, name_='SEQUENCE', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ReferenceSequenceType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.ASSEMBLY is not None:
            showIndent(outfile, level)
            outfile.write('ASSEMBLY=model_.ReferenceAssemblyType(\n')
            self.ASSEMBLY.exportLiteral(outfile, level, name_='ASSEMBLY')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('SEQUENCE=[\n')
        level += 1
        for SEQUENCE_ in self.SEQUENCE:
            showIndent(outfile, level)
            outfile.write('model_.SEQUENCEType(\n')
            SEQUENCE_.exportLiteral(outfile, level, name_='SEQUENCEType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'ASSEMBLY':
            obj_ = ReferenceAssemblyType.factory()
            obj_.build(child_)
            self.ASSEMBLY = obj_
            obj_.original_tagname_ = 'ASSEMBLY'
        elif nodeName_ == 'SEQUENCE':
            obj_ = SEQUENCEType.factory()
            obj_.build(child_)
            self.SEQUENCE.append(obj_)
            obj_.original_tagname_ = 'SEQUENCE'
# end class ReferenceSequenceType


class ProcessingType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, PIPELINE=None, DIRECTIVES=None):
        self.original_tagname_ = None
        self.PIPELINE = PIPELINE
        self.DIRECTIVES = DIRECTIVES
    def factory(*args_, **kwargs_):
        if ProcessingType.subclass:
            return ProcessingType.subclass(*args_, **kwargs_)
        else:
            return ProcessingType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PIPELINE(self): return self.PIPELINE
    def set_PIPELINE(self, PIPELINE): self.PIPELINE = PIPELINE
    def get_DIRECTIVES(self): return self.DIRECTIVES
    def set_DIRECTIVES(self, DIRECTIVES): self.DIRECTIVES = DIRECTIVES
    def hasContent_(self):
        if (
            self.PIPELINE is not None or
            self.DIRECTIVES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ProcessingType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ProcessingType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ProcessingType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ProcessingType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ProcessingType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PIPELINE is not None:
            self.PIPELINE.export(outfile, level, namespace_, name_='PIPELINE', pretty_print=pretty_print)
        if self.DIRECTIVES is not None:
            self.DIRECTIVES.export(outfile, level, namespace_, name_='DIRECTIVES', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ProcessingType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PIPELINE is not None:
            showIndent(outfile, level)
            outfile.write('PIPELINE=model_.PipelineType(\n')
            self.PIPELINE.exportLiteral(outfile, level, name_='PIPELINE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DIRECTIVES is not None:
            showIndent(outfile, level)
            outfile.write('DIRECTIVES=model_.SequencingDirectivesType(\n')
            self.DIRECTIVES.exportLiteral(outfile, level, name_='DIRECTIVES')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PIPELINE':
            obj_ = PipelineType.factory()
            obj_.build(child_)
            self.PIPELINE = obj_
            obj_.original_tagname_ = 'PIPELINE'
        elif nodeName_ == 'DIRECTIVES':
            obj_ = SequencingDirectivesType.factory()
            obj_.build(child_)
            self.DIRECTIVES = obj_
            obj_.original_tagname_ = 'DIRECTIVES'
# end class ProcessingType


class READ_LABELType(GeneratedsSuper):
    """Assignment of read_group_tag to decoded read"""
    subclass = None
    superclass = None
    def __init__(self, read_group_tag=None, valueOf_=None):
        self.original_tagname_ = None
        self.read_group_tag = _cast(None, read_group_tag)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if READ_LABELType.subclass:
            return READ_LABELType.subclass(*args_, **kwargs_)
        else:
            return READ_LABELType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_read_group_tag(self): return self.read_group_tag
    def set_read_group_tag(self, read_group_tag): self.read_group_tag = read_group_tag
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='READ_LABELType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='READ_LABELType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='READ_LABELType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='READ_LABELType'):
        if self.read_group_tag is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            outfile.write(' read_group_tag=%s' % (self.gds_format_string(quote_attrib(self.read_group_tag).encode(ExternalEncoding), input_name='read_group_tag'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='READ_LABELType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='READ_LABELType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.read_group_tag is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            showIndent(outfile, level)
            outfile.write('read_group_tag="%s",\n' % (self.read_group_tag,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('read_group_tag', node)
        if value is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            self.read_group_tag = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class READ_LABELType


class POOLType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DEFAULT_MEMBER=None, MEMBER=None):
        self.original_tagname_ = None
        self.DEFAULT_MEMBER = DEFAULT_MEMBER
        if MEMBER is None:
            self.MEMBER = []
        else:
            self.MEMBER = MEMBER
    def factory(*args_, **kwargs_):
        if POOLType.subclass:
            return POOLType.subclass(*args_, **kwargs_)
        else:
            return POOLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DEFAULT_MEMBER(self): return self.DEFAULT_MEMBER
    def set_DEFAULT_MEMBER(self, DEFAULT_MEMBER): self.DEFAULT_MEMBER = DEFAULT_MEMBER
    def get_MEMBER(self): return self.MEMBER
    def set_MEMBER(self, MEMBER): self.MEMBER = MEMBER
    def add_MEMBER(self, value): self.MEMBER.append(value)
    def insert_MEMBER_at(self, index, value): self.MEMBER.insert(index, value)
    def replace_MEMBER_at(self, index, value): self.MEMBER[index] = value
    def hasContent_(self):
        if (
            self.DEFAULT_MEMBER is not None or
            self.MEMBER
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='POOLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='POOLType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='POOLType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='POOLType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='POOLType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DEFAULT_MEMBER is not None:
            self.DEFAULT_MEMBER.export(outfile, level, namespace_, name_='DEFAULT_MEMBER', pretty_print=pretty_print)
        for MEMBER_ in self.MEMBER:
            MEMBER_.export(outfile, level, namespace_, name_='MEMBER', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='POOLType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DEFAULT_MEMBER is not None:
            showIndent(outfile, level)
            outfile.write('DEFAULT_MEMBER=model_.PoolMemberType(\n')
            self.DEFAULT_MEMBER.exportLiteral(outfile, level, name_='DEFAULT_MEMBER')
            showIndent(outfile, level)
            outfile.write('),\n')
        showIndent(outfile, level)
        outfile.write('MEMBER=[\n')
        level += 1
        for MEMBER_ in self.MEMBER:
            showIndent(outfile, level)
            outfile.write('model_.PoolMemberType(\n')
            MEMBER_.exportLiteral(outfile, level, name_='PoolMemberType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DEFAULT_MEMBER':
            obj_ = PoolMemberType.factory()
            obj_.build(child_)
            self.DEFAULT_MEMBER = obj_
            obj_.original_tagname_ = 'DEFAULT_MEMBER'
        elif nodeName_ == 'MEMBER':
            obj_ = PoolMemberType.factory()
            obj_.build(child_)
            self.MEMBER.append(obj_)
            obj_.original_tagname_ = 'MEMBER'
# end class POOLType


class LIBRARY_LAYOUTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SINGLE=None, PAIRED=None):
        self.original_tagname_ = None
        self.SINGLE = SINGLE
        self.PAIRED = PAIRED
    def factory(*args_, **kwargs_):
        if LIBRARY_LAYOUTType.subclass:
            return LIBRARY_LAYOUTType.subclass(*args_, **kwargs_)
        else:
            return LIBRARY_LAYOUTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SINGLE(self): return self.SINGLE
    def set_SINGLE(self, SINGLE): self.SINGLE = SINGLE
    def get_PAIRED(self): return self.PAIRED
    def set_PAIRED(self, PAIRED): self.PAIRED = PAIRED
    def hasContent_(self):
        if (
            self.SINGLE is not None or
            self.PAIRED is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LIBRARY_LAYOUTType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LIBRARY_LAYOUTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LIBRARY_LAYOUTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LIBRARY_LAYOUTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LIBRARY_LAYOUTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SINGLE is not None:
            self.SINGLE.export(outfile, level, namespace_, name_='SINGLE', pretty_print=pretty_print)
        if self.PAIRED is not None:
            self.PAIRED.export(outfile, level, namespace_, name_='PAIRED', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LIBRARY_LAYOUTType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SINGLE is not None:
            showIndent(outfile, level)
            outfile.write('SINGLE=model_.SINGLEType(\n')
            self.SINGLE.exportLiteral(outfile, level, name_='SINGLE')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PAIRED is not None:
            showIndent(outfile, level)
            outfile.write('PAIRED=model_.PAIREDType(\n')
            self.PAIRED.exportLiteral(outfile, level, name_='PAIRED')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SINGLE':
            obj_ = SINGLEType.factory()
            obj_.build(child_)
            self.SINGLE = obj_
            obj_.original_tagname_ = 'SINGLE'
        elif nodeName_ == 'PAIRED':
            obj_ = PAIREDType.factory()
            obj_.build(child_)
            self.PAIRED = obj_
            obj_.original_tagname_ = 'PAIRED'
# end class LIBRARY_LAYOUTType


class SINGLEType(GeneratedsSuper):
    """Reads are unpaired (usual case)."""
    subclass = None
    superclass = None
    def __init__(self):
        self.original_tagname_ = None
    def factory(*args_, **kwargs_):
        if SINGLEType.subclass:
            return SINGLEType.subclass(*args_, **kwargs_)
        else:
            return SINGLEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SINGLEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SINGLEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SINGLEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SINGLEType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SINGLEType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SINGLEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SINGLEType


class PAIREDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, NOMINAL_SDEV=None, NOMINAL_LENGTH=None):
        self.original_tagname_ = None
        self.NOMINAL_SDEV = _cast(float, NOMINAL_SDEV)
        self.NOMINAL_LENGTH = _cast(int, NOMINAL_LENGTH)
    def factory(*args_, **kwargs_):
        if PAIREDType.subclass:
            return PAIREDType.subclass(*args_, **kwargs_)
        else:
            return PAIREDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_NOMINAL_SDEV(self): return self.NOMINAL_SDEV
    def set_NOMINAL_SDEV(self, NOMINAL_SDEV): self.NOMINAL_SDEV = NOMINAL_SDEV
    def get_NOMINAL_LENGTH(self): return self.NOMINAL_LENGTH
    def set_NOMINAL_LENGTH(self, NOMINAL_LENGTH): self.NOMINAL_LENGTH = NOMINAL_LENGTH
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PAIREDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PAIREDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PAIREDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PAIREDType'):
        if self.NOMINAL_SDEV is not None and 'NOMINAL_SDEV' not in already_processed:
            already_processed.add('NOMINAL_SDEV')
            outfile.write(' NOMINAL_SDEV="%s"' % self.gds_format_double(self.NOMINAL_SDEV, input_name='NOMINAL_SDEV'))
        if self.NOMINAL_LENGTH is not None and 'NOMINAL_LENGTH' not in already_processed:
            already_processed.add('NOMINAL_LENGTH')
            outfile.write(' NOMINAL_LENGTH="%s"' % self.gds_format_integer(self.NOMINAL_LENGTH, input_name='NOMINAL_LENGTH'))
    def exportChildren(self, outfile, level, namespace_='', name_='PAIREDType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='PAIREDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.NOMINAL_SDEV is not None and 'NOMINAL_SDEV' not in already_processed:
            already_processed.add('NOMINAL_SDEV')
            showIndent(outfile, level)
            outfile.write('NOMINAL_SDEV=%e,\n' % (self.NOMINAL_SDEV,))
        if self.NOMINAL_LENGTH is not None and 'NOMINAL_LENGTH' not in already_processed:
            already_processed.add('NOMINAL_LENGTH')
            showIndent(outfile, level)
            outfile.write('NOMINAL_LENGTH=%d,\n' % (self.NOMINAL_LENGTH,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('NOMINAL_SDEV', node)
        if value is not None and 'NOMINAL_SDEV' not in already_processed:
            already_processed.add('NOMINAL_SDEV')
            try:
                self.NOMINAL_SDEV = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (NOMINAL_SDEV): %s' % exp)
        value = find_attr_value_('NOMINAL_LENGTH', node)
        if value is not None and 'NOMINAL_LENGTH' not in already_processed:
            already_processed.add('NOMINAL_LENGTH')
            try:
                self.NOMINAL_LENGTH = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.NOMINAL_LENGTH < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class PAIREDType


class TARGETED_LOCIType(GeneratedsSuper):
    """Names the gene(s) or locus(loci) or other genomic feature(s)
    targeted by the sequence."""
    subclass = None
    superclass = None
    def __init__(self, LOCUS=None):
        self.original_tagname_ = None
        if LOCUS is None:
            self.LOCUS = []
        else:
            self.LOCUS = LOCUS
    def factory(*args_, **kwargs_):
        if TARGETED_LOCIType.subclass:
            return TARGETED_LOCIType.subclass(*args_, **kwargs_)
        else:
            return TARGETED_LOCIType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LOCUS(self): return self.LOCUS
    def set_LOCUS(self, LOCUS): self.LOCUS = LOCUS
    def add_LOCUS(self, value): self.LOCUS.append(value)
    def insert_LOCUS_at(self, index, value): self.LOCUS.insert(index, value)
    def replace_LOCUS_at(self, index, value): self.LOCUS[index] = value
    def hasContent_(self):
        if (
            self.LOCUS
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='TARGETED_LOCIType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='TARGETED_LOCIType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='TARGETED_LOCIType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='TARGETED_LOCIType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='TARGETED_LOCIType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for LOCUS_ in self.LOCUS:
            LOCUS_.export(outfile, level, namespace_, name_='LOCUS', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='TARGETED_LOCIType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('LOCUS=[\n')
        level += 1
        for LOCUS_ in self.LOCUS:
            showIndent(outfile, level)
            outfile.write('model_.LOCUSType(\n')
            LOCUS_.exportLiteral(outfile, level, name_='LOCUSType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LOCUS':
            obj_ = LOCUSType.factory()
            obj_.build(child_)
            self.LOCUS.append(obj_)
            obj_.original_tagname_ = 'LOCUS'
# end class TARGETED_LOCIType


class LOCUSType(GeneratedsSuper):
    """Bacterial small subunit ribosomal RNA, a locus used for phylogenetic
    studies of bacteria and as a target for random target PCR in
    environmental biodiversity screening. Eukaryotic small subunit
    ribosomal RNA, a locus used for phylogenetic studies of
    eukaryotes and as a target for random target PCR in
    environmental biodiversity screening. RuBisCO large subunit :
    ribulose-1,5-bisphosphate carboxylase/oxygenase large subunit, a
    locus used for phylogenetic studies of plants. Maturase K gene,
    a locus used for phylogenetic studies of plants. Mitochondrial
    cytochrome c oxidase 1 gene, a locus used for phylogenetic
    studies of animals Internal transcribed spacers 1 and 2 plus
    5.8S rRNA region, a locus used for phylogenetic studies of
    fungi. All exonic regions of the genome. Other locus, please
    describe. Submitter supplied description of alternate locus and
    auxiliary information."""
    subclass = None
    superclass = None
    def __init__(self, locus_name=None, description=None, PROBE_SET=None):
        self.original_tagname_ = None
        self.locus_name = _cast(None, locus_name)
        self.description = _cast(None, description)
        self.PROBE_SET = PROBE_SET
    def factory(*args_, **kwargs_):
        if LOCUSType.subclass:
            return LOCUSType.subclass(*args_, **kwargs_)
        else:
            return LOCUSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_PROBE_SET(self): return self.PROBE_SET
    def set_PROBE_SET(self, PROBE_SET): self.PROBE_SET = PROBE_SET
    def get_locus_name(self): return self.locus_name
    def set_locus_name(self, locus_name): self.locus_name = locus_name
    def get_description(self): return self.description
    def set_description(self, description): self.description = description
    def hasContent_(self):
        if (
            self.PROBE_SET is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LOCUSType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LOCUSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LOCUSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LOCUSType'):
        if self.locus_name is not None and 'locus_name' not in already_processed:
            already_processed.add('locus_name')
            outfile.write(' locus_name=%s' % (self.gds_format_string(quote_attrib(self.locus_name).encode(ExternalEncoding), input_name='locus_name'), ))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            outfile.write(' description=%s' % (self.gds_format_string(quote_attrib(self.description).encode(ExternalEncoding), input_name='description'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='LOCUSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.PROBE_SET is not None:
            self.PROBE_SET.export(outfile, level, namespace_, name_='PROBE_SET', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='LOCUSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.locus_name is not None and 'locus_name' not in already_processed:
            already_processed.add('locus_name')
            showIndent(outfile, level)
            outfile.write('locus_name="%s",\n' % (self.locus_name,))
        if self.description is not None and 'description' not in already_processed:
            already_processed.add('description')
            showIndent(outfile, level)
            outfile.write('description="%s",\n' % (self.description,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.PROBE_SET is not None:
            showIndent(outfile, level)
            outfile.write('PROBE_SET=model_.XRefType(\n')
            self.PROBE_SET.exportLiteral(outfile, level, name_='PROBE_SET')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('locus_name', node)
        if value is not None and 'locus_name' not in already_processed:
            already_processed.add('locus_name')
            self.locus_name = value
        value = find_attr_value_('description', node)
        if value is not None and 'description' not in already_processed:
            already_processed.add('description')
            self.description = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'PROBE_SET':
            obj_ = XRefType.factory()
            obj_.build(child_)
            self.PROBE_SET = obj_
            obj_.original_tagname_ = 'PROBE_SET'
# end class LOCUSType


class STUDY_REFType(RefObjectType):
    subclass = None
    superclass = RefObjectType
    def __init__(self, accession=None, refname=None, refcenter=None, IDENTIFIERS=None):
        self.original_tagname_ = None
        super(STUDY_REFType, self).__init__(accession, refname, refcenter, IDENTIFIERS, )
    def factory(*args_, **kwargs_):
        if STUDY_REFType.subclass:
            return STUDY_REFType.subclass(*args_, **kwargs_)
        else:
            return STUDY_REFType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def hasContent_(self):
        if (
            super(STUDY_REFType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='STUDY_REFType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STUDY_REFType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='STUDY_REFType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STUDY_REFType'):
        super(STUDY_REFType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='STUDY_REFType')
    def exportChildren(self, outfile, level, namespace_='', name_='STUDY_REFType', fromsubclass_=False, pretty_print=True):
        super(STUDY_REFType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='STUDY_REFType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(STUDY_REFType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(STUDY_REFType, self).exportLiteralChildren(outfile, level, name_)
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(STUDY_REFType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        super(STUDY_REFType, self).buildChildren(child_, node, nodeName_, True)
        pass
# end class STUDY_REFType


class EXPERIMENT_LINKSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EXPERIMENT_LINK=None):
        self.original_tagname_ = None
        if EXPERIMENT_LINK is None:
            self.EXPERIMENT_LINK = []
        else:
            self.EXPERIMENT_LINK = EXPERIMENT_LINK
    def factory(*args_, **kwargs_):
        if EXPERIMENT_LINKSType.subclass:
            return EXPERIMENT_LINKSType.subclass(*args_, **kwargs_)
        else:
            return EXPERIMENT_LINKSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EXPERIMENT_LINK(self): return self.EXPERIMENT_LINK
    def set_EXPERIMENT_LINK(self, EXPERIMENT_LINK): self.EXPERIMENT_LINK = EXPERIMENT_LINK
    def add_EXPERIMENT_LINK(self, value): self.EXPERIMENT_LINK.append(value)
    def insert_EXPERIMENT_LINK_at(self, index, value): self.EXPERIMENT_LINK.insert(index, value)
    def replace_EXPERIMENT_LINK_at(self, index, value): self.EXPERIMENT_LINK[index] = value
    def hasContent_(self):
        if (
            self.EXPERIMENT_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EXPERIMENT_LINKSType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EXPERIMENT_LINKSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EXPERIMENT_LINKSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EXPERIMENT_LINKSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EXPERIMENT_LINKSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EXPERIMENT_LINK_ in self.EXPERIMENT_LINK:
            EXPERIMENT_LINK_.export(outfile, level, namespace_, name_='EXPERIMENT_LINK', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EXPERIMENT_LINKSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('EXPERIMENT_LINK=[\n')
        level += 1
        for EXPERIMENT_LINK_ in self.EXPERIMENT_LINK:
            showIndent(outfile, level)
            outfile.write('model_.LinkType(\n')
            EXPERIMENT_LINK_.exportLiteral(outfile, level, name_='LinkType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EXPERIMENT_LINK':
            obj_ = LinkType.factory()
            obj_.build(child_)
            self.EXPERIMENT_LINK.append(obj_)
            obj_.original_tagname_ = 'EXPERIMENT_LINK'
# end class EXPERIMENT_LINKSType


class EXPERIMENT_ATTRIBUTESType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, EXPERIMENT_ATTRIBUTE=None):
        self.original_tagname_ = None
        if EXPERIMENT_ATTRIBUTE is None:
            self.EXPERIMENT_ATTRIBUTE = []
        else:
            self.EXPERIMENT_ATTRIBUTE = EXPERIMENT_ATTRIBUTE
    def factory(*args_, **kwargs_):
        if EXPERIMENT_ATTRIBUTESType.subclass:
            return EXPERIMENT_ATTRIBUTESType.subclass(*args_, **kwargs_)
        else:
            return EXPERIMENT_ATTRIBUTESType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_EXPERIMENT_ATTRIBUTE(self): return self.EXPERIMENT_ATTRIBUTE
    def set_EXPERIMENT_ATTRIBUTE(self, EXPERIMENT_ATTRIBUTE): self.EXPERIMENT_ATTRIBUTE = EXPERIMENT_ATTRIBUTE
    def add_EXPERIMENT_ATTRIBUTE(self, value): self.EXPERIMENT_ATTRIBUTE.append(value)
    def insert_EXPERIMENT_ATTRIBUTE_at(self, index, value): self.EXPERIMENT_ATTRIBUTE.insert(index, value)
    def replace_EXPERIMENT_ATTRIBUTE_at(self, index, value): self.EXPERIMENT_ATTRIBUTE[index] = value
    def hasContent_(self):
        if (
            self.EXPERIMENT_ATTRIBUTE
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EXPERIMENT_ATTRIBUTESType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EXPERIMENT_ATTRIBUTESType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EXPERIMENT_ATTRIBUTESType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EXPERIMENT_ATTRIBUTESType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='EXPERIMENT_ATTRIBUTESType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for EXPERIMENT_ATTRIBUTE_ in self.EXPERIMENT_ATTRIBUTE:
            EXPERIMENT_ATTRIBUTE_.export(outfile, level, namespace_, name_='EXPERIMENT_ATTRIBUTE', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EXPERIMENT_ATTRIBUTESType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('EXPERIMENT_ATTRIBUTE=[\n')
        level += 1
        for EXPERIMENT_ATTRIBUTE_ in self.EXPERIMENT_ATTRIBUTE:
            showIndent(outfile, level)
            outfile.write('model_.AttributeType(\n')
            EXPERIMENT_ATTRIBUTE_.exportLiteral(outfile, level, name_='AttributeType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'EXPERIMENT_ATTRIBUTE':
            obj_ = AttributeType.factory()
            obj_.build(child_)
            self.EXPERIMENT_ATTRIBUTE.append(obj_)
            obj_.original_tagname_ = 'EXPERIMENT_ATTRIBUTE'
# end class EXPERIMENT_ATTRIBUTESType


class URL_LINKType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL
    def factory(*args_, **kwargs_):
        if URL_LINKType.subclass:
            return URL_LINKType.subclass(*args_, **kwargs_)
        else:
            return URL_LINKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def hasContent_(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='URL_LINKType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL_LINKType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URL_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL_LINKType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URL_LINKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='URL_LINKType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LABEL is not None:
            showIndent(outfile, level)
            outfile.write('LABEL=%s,\n' % quote_python(self.LABEL).encode(ExternalEncoding))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URL_LINKType


class ENTREZ_LINKType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DB=None, ID=None, QUERY=None, LABEL=None):
        self.original_tagname_ = None
        self.DB = DB
        self.ID = ID
        self.QUERY = QUERY
        self.LABEL = LABEL
    def factory(*args_, **kwargs_):
        if ENTREZ_LINKType.subclass:
            return ENTREZ_LINKType.subclass(*args_, **kwargs_)
        else:
            return ENTREZ_LINKType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DB(self): return self.DB
    def set_DB(self, DB): self.DB = DB
    def get_ID(self): return self.ID
    def set_ID(self, ID): self.ID = ID
    def get_QUERY(self): return self.QUERY
    def set_QUERY(self, QUERY): self.QUERY = QUERY
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def hasContent_(self):
        if (
            self.DB is not None or
            self.ID is not None or
            self.QUERY is not None or
            self.LABEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ENTREZ_LINKType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ENTREZ_LINKType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ENTREZ_LINKType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ENTREZ_LINKType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ENTREZ_LINKType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DB is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDB>%s</%sDB>%s' % (namespace_, self.gds_format_string(quote_xml(self.DB).encode(ExternalEncoding), input_name='DB'), namespace_, eol_))
        if self.ID is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sID>%s</%sID>%s' % (namespace_, self.gds_format_integer(self.ID, input_name='ID'), namespace_, eol_))
        if self.QUERY is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sQUERY>%s</%sQUERY>%s' % (namespace_, self.gds_format_string(quote_xml(self.QUERY).encode(ExternalEncoding), input_name='QUERY'), namespace_, eol_))
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ENTREZ_LINKType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DB is not None:
            showIndent(outfile, level)
            outfile.write('DB=%s,\n' % quote_python(self.DB).encode(ExternalEncoding))
        if self.ID is not None:
            showIndent(outfile, level)
            outfile.write('ID=%d,\n' % self.ID)
        if self.QUERY is not None:
            showIndent(outfile, level)
            outfile.write('QUERY=%s,\n' % quote_python(self.QUERY).encode(ExternalEncoding))
        if self.LABEL is not None:
            showIndent(outfile, level)
            outfile.write('LABEL=%s,\n' % quote_python(self.LABEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DB':
            DB_ = child_.text
            DB_ = self.gds_validate_string(DB_, node, 'DB')
            self.DB = DB_
        elif nodeName_ == 'ID':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'ID')
            self.ID = ival_
        elif nodeName_ == 'QUERY':
            QUERY_ = child_.text
            QUERY_ = self.gds_validate_string(QUERY_, node, 'QUERY')
            self.QUERY = QUERY_
        elif nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
# end class ENTREZ_LINKType


class SPOT_DECODE_SPECType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, SPOT_LENGTH=None, READ_SPEC=None):
        self.original_tagname_ = None
        self.SPOT_LENGTH = SPOT_LENGTH
        if READ_SPEC is None:
            self.READ_SPEC = []
        else:
            self.READ_SPEC = READ_SPEC
    def factory(*args_, **kwargs_):
        if SPOT_DECODE_SPECType.subclass:
            return SPOT_DECODE_SPECType.subclass(*args_, **kwargs_)
        else:
            return SPOT_DECODE_SPECType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_SPOT_LENGTH(self): return self.SPOT_LENGTH
    def set_SPOT_LENGTH(self, SPOT_LENGTH): self.SPOT_LENGTH = SPOT_LENGTH
    def get_READ_SPEC(self): return self.READ_SPEC
    def set_READ_SPEC(self, READ_SPEC): self.READ_SPEC = READ_SPEC
    def add_READ_SPEC(self, value): self.READ_SPEC.append(value)
    def insert_READ_SPEC_at(self, index, value): self.READ_SPEC.insert(index, value)
    def replace_READ_SPEC_at(self, index, value): self.READ_SPEC[index] = value
    def hasContent_(self):
        if (
            self.SPOT_LENGTH is not None or
            self.READ_SPEC
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SPOT_DECODE_SPECType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SPOT_DECODE_SPECType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SPOT_DECODE_SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SPOT_DECODE_SPECType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='SPOT_DECODE_SPECType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.SPOT_LENGTH is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSPOT_LENGTH>%s</%sSPOT_LENGTH>%s' % (namespace_, self.gds_format_integer(self.SPOT_LENGTH, input_name='SPOT_LENGTH'), namespace_, eol_))
        for READ_SPEC_ in self.READ_SPEC:
            READ_SPEC_.export(outfile, level, namespace_, name_='READ_SPEC', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SPOT_DECODE_SPECType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.SPOT_LENGTH is not None:
            showIndent(outfile, level)
            outfile.write('SPOT_LENGTH=%d,\n' % self.SPOT_LENGTH)
        showIndent(outfile, level)
        outfile.write('READ_SPEC=[\n')
        level += 1
        for READ_SPEC_ in self.READ_SPEC:
            showIndent(outfile, level)
            outfile.write('model_.READ_SPECType(\n')
            READ_SPEC_.exportLiteral(outfile, level, name_='READ_SPECType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'SPOT_LENGTH':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'SPOT_LENGTH')
            self.SPOT_LENGTH = ival_
        elif nodeName_ == 'READ_SPEC':
            obj_ = READ_SPECType.factory()
            obj_.build(child_)
            self.READ_SPEC.append(obj_)
            obj_.original_tagname_ = 'READ_SPEC'
# end class SPOT_DECODE_SPECType


class READ_SPECType(GeneratedsSuper):
    """There are various methods to ordering the reads on the spot."""
    subclass = None
    superclass = None
    def __init__(self, READ_INDEX=None, READ_LABEL=None, READ_CLASS=None, READ_TYPE='Forward', RELATIVE_ORDER=None, BASE_COORD=None, EXPECTED_BASECALL_TABLE=None):
        self.original_tagname_ = None
        self.READ_INDEX = READ_INDEX
        self.READ_LABEL = READ_LABEL
        self.READ_CLASS = READ_CLASS
        self.validate_READ_CLASSType(self.READ_CLASS)
        self.READ_TYPE = READ_TYPE
        self.validate_READ_TYPEType(self.READ_TYPE)
        self.RELATIVE_ORDER = RELATIVE_ORDER
        self.BASE_COORD = BASE_COORD
        self.EXPECTED_BASECALL_TABLE = EXPECTED_BASECALL_TABLE
    def factory(*args_, **kwargs_):
        if READ_SPECType.subclass:
            return READ_SPECType.subclass(*args_, **kwargs_)
        else:
            return READ_SPECType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_READ_INDEX(self): return self.READ_INDEX
    def set_READ_INDEX(self, READ_INDEX): self.READ_INDEX = READ_INDEX
    def get_READ_LABEL(self): return self.READ_LABEL
    def set_READ_LABEL(self, READ_LABEL): self.READ_LABEL = READ_LABEL
    def get_READ_CLASS(self): return self.READ_CLASS
    def set_READ_CLASS(self, READ_CLASS): self.READ_CLASS = READ_CLASS
    def get_READ_TYPE(self): return self.READ_TYPE
    def set_READ_TYPE(self, READ_TYPE): self.READ_TYPE = READ_TYPE
    def get_RELATIVE_ORDER(self): return self.RELATIVE_ORDER
    def set_RELATIVE_ORDER(self, RELATIVE_ORDER): self.RELATIVE_ORDER = RELATIVE_ORDER
    def get_BASE_COORD(self): return self.BASE_COORD
    def set_BASE_COORD(self, BASE_COORD): self.BASE_COORD = BASE_COORD
    def get_EXPECTED_BASECALL_TABLE(self): return self.EXPECTED_BASECALL_TABLE
    def set_EXPECTED_BASECALL_TABLE(self, EXPECTED_BASECALL_TABLE): self.EXPECTED_BASECALL_TABLE = EXPECTED_BASECALL_TABLE
    def validate_READ_CLASSType(self, value):
        # Validate type READ_CLASSType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Application Read', 'Technical Read']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on READ_CLASSType' % {"value" : value.encode("utf-8")} )
    def validate_READ_TYPEType(self, value):
        # Validate type READ_TYPEType, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Forward', 'Reverse', 'Adapter', 'Primer', 'Linker', 'BarCode', 'Other']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on READ_TYPEType' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.READ_INDEX is not None or
            self.READ_LABEL is not None or
            self.READ_CLASS is not None or
            # self.READ_TYPE != "Forward" or
            self.RELATIVE_ORDER is not None or
            self.BASE_COORD is not None or
            self.EXPECTED_BASECALL_TABLE is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='READ_SPECType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='READ_SPECType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='READ_SPECType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='READ_SPECType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='READ_SPECType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.READ_INDEX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_INDEX>%s</%sREAD_INDEX>%s' % (namespace_, self.gds_format_integer(self.READ_INDEX, input_name='READ_INDEX'), namespace_, eol_))
        if self.READ_LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_LABEL>%s</%sREAD_LABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.READ_LABEL).encode(ExternalEncoding), input_name='READ_LABEL'), namespace_, eol_))
        if self.READ_CLASS is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_CLASS>%s</%sREAD_CLASS>%s' % (namespace_, self.gds_format_string(quote_xml(self.READ_CLASS).encode(ExternalEncoding), input_name='READ_CLASS'), namespace_, eol_))
        if self.READ_TYPE == "Forward":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_TYPE>%s</%sREAD_TYPE>%s' % (namespace_, self.gds_format_string(quote_xml(self.READ_TYPE).encode(ExternalEncoding), input_name='READ_TYPE'), namespace_, eol_))
        if self.READ_TYPE == "Reverse":
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sREAD_TYPE>%s</%sREAD_TYPE>%s' % (namespace_, self.gds_format_string(quote_xml(self.READ_TYPE).encode(ExternalEncoding), input_name='READ_TYPE'), namespace_, eol_))
        if self.RELATIVE_ORDER is not None:
            self.RELATIVE_ORDER.export(outfile, level, namespace_, name_='RELATIVE_ORDER', pretty_print=pretty_print)
        if self.BASE_COORD is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sBASE_COORD>%s</%sBASE_COORD>%s' % (namespace_, self.gds_format_integer(self.BASE_COORD, input_name='BASE_COORD'), namespace_, eol_))
        if self.EXPECTED_BASECALL_TABLE is not None:
            self.EXPECTED_BASECALL_TABLE.export(outfile, level, namespace_, name_='EXPECTED_BASECALL_TABLE', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='READ_SPECType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.READ_INDEX is not None:
            showIndent(outfile, level)
            outfile.write('READ_INDEX=%d,\n' % self.READ_INDEX)
        if self.READ_LABEL is not None:
            showIndent(outfile, level)
            outfile.write('READ_LABEL=%s,\n' % quote_python(self.READ_LABEL).encode(ExternalEncoding))
        if self.READ_CLASS is not None:
            showIndent(outfile, level)
            outfile.write('READ_CLASS=%s,\n' % quote_python(self.READ_CLASS).encode(ExternalEncoding))
        if self.READ_TYPE is not None:
            showIndent(outfile, level)
            outfile.write('READ_TYPE=%s,\n' % quote_python(self.READ_TYPE).encode(ExternalEncoding))
        if self.RELATIVE_ORDER is not None:
            showIndent(outfile, level)
            outfile.write('RELATIVE_ORDER=model_.RELATIVE_ORDERType(\n')
            self.RELATIVE_ORDER.exportLiteral(outfile, level, name_='RELATIVE_ORDER')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.BASE_COORD is not None:
            showIndent(outfile, level)
            outfile.write('BASE_COORD=%d,\n' % self.BASE_COORD)
        if self.EXPECTED_BASECALL_TABLE is not None:
            showIndent(outfile, level)
            outfile.write('EXPECTED_BASECALL_TABLE=model_.EXPECTED_BASECALL_TABLEType(\n')
            self.EXPECTED_BASECALL_TABLE.exportLiteral(outfile, level, name_='EXPECTED_BASECALL_TABLE')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'READ_INDEX':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            if ival_ < 0:
                raise_parse_error(child_, 'requires nonNegativeInteger')
            ival_ = self.gds_validate_integer(ival_, node, 'READ_INDEX')
            self.READ_INDEX = ival_
        elif nodeName_ == 'READ_LABEL':
            READ_LABEL_ = child_.text
            READ_LABEL_ = self.gds_validate_string(READ_LABEL_, node, 'READ_LABEL')
            self.READ_LABEL = READ_LABEL_
        elif nodeName_ == 'READ_CLASS':
            READ_CLASS_ = child_.text
            READ_CLASS_ = self.gds_validate_string(READ_CLASS_, node, 'READ_CLASS')
            self.READ_CLASS = READ_CLASS_
            # validate type READ_CLASSType
            self.validate_READ_CLASSType(self.READ_CLASS)
        elif nodeName_ == 'READ_TYPE':
            READ_TYPE_ = child_.text
            READ_TYPE_ = self.gds_validate_string(READ_TYPE_, node, 'READ_TYPE')
            self.READ_TYPE = READ_TYPE_
            # validate type READ_TYPEType
            self.validate_READ_TYPEType(self.READ_TYPE)
        elif nodeName_ == 'RELATIVE_ORDER':
            obj_ = RELATIVE_ORDERType.factory()
            obj_.build(child_)
            self.RELATIVE_ORDER = obj_
            obj_.original_tagname_ = 'RELATIVE_ORDER'
        elif nodeName_ == 'BASE_COORD':
            sval_ = child_.text
            try:
                ival_ = int(sval_)
            except (TypeError, ValueError) as exp:
                raise_parse_error(child_, 'requires integer: %s' % exp)
            ival_ = self.gds_validate_integer(ival_, node, 'BASE_COORD')
            self.BASE_COORD = ival_
        elif nodeName_ == 'EXPECTED_BASECALL_TABLE':
            obj_ = EXPECTED_BASECALL_TABLEType.factory()
            obj_.build(child_)
            self.EXPECTED_BASECALL_TABLE = obj_
            obj_.original_tagname_ = 'EXPECTED_BASECALL_TABLE'
# end class READ_SPECType


class RELATIVE_ORDERType(GeneratedsSuper):
    """Specify the read index that precedes this read. Specify the read
    index that follows this read."""
    subclass = None
    superclass = None
    def __init__(self, follows_read_index=None, precedes_read_index=None):
        self.original_tagname_ = None
        self.follows_read_index = _cast(int, follows_read_index)
        self.precedes_read_index = _cast(int, precedes_read_index)
    def factory(*args_, **kwargs_):
        if RELATIVE_ORDERType.subclass:
            return RELATIVE_ORDERType.subclass(*args_, **kwargs_)
        else:
            return RELATIVE_ORDERType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_follows_read_index(self): return self.follows_read_index
    def set_follows_read_index(self, follows_read_index): self.follows_read_index = follows_read_index
    def get_precedes_read_index(self): return self.precedes_read_index
    def set_precedes_read_index(self, precedes_read_index): self.precedes_read_index = precedes_read_index
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='RELATIVE_ORDERType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='RELATIVE_ORDERType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='RELATIVE_ORDERType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='RELATIVE_ORDERType'):
        if self.follows_read_index is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            outfile.write(' follows_read_index="%s"' % self.gds_format_integer(self.follows_read_index, input_name='follows_read_index'))
        if self.precedes_read_index is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            outfile.write(' precedes_read_index="%s"' % self.gds_format_integer(self.precedes_read_index, input_name='precedes_read_index'))
    def exportChildren(self, outfile, level, namespace_='', name_='RELATIVE_ORDERType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='RELATIVE_ORDERType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.follows_read_index is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            showIndent(outfile, level)
            outfile.write('follows_read_index=%d,\n' % (self.follows_read_index,))
        if self.precedes_read_index is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            showIndent(outfile, level)
            outfile.write('precedes_read_index=%d,\n' % (self.precedes_read_index,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('follows_read_index', node)
        if value is not None and 'follows_read_index' not in already_processed:
            already_processed.add('follows_read_index')
            try:
                self.follows_read_index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.follows_read_index < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('precedes_read_index', node)
        if value is not None and 'precedes_read_index' not in already_processed:
            already_processed.add('precedes_read_index')
            try:
                self.precedes_read_index = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.precedes_read_index < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class RELATIVE_ORDERType


class EXPECTED_BASECALL_TABLEType(GeneratedsSuper):
    """Specify whether the spot should have a default length for this tag
    if the expected base cannot be matched. Specify an optional
    starting point for tag (base offset from 1)."""
    subclass = None
    superclass = None
    def __init__(self, default_length=None, base_coord=None, BASECALL=None):
        self.original_tagname_ = None
        self.default_length = _cast(int, default_length)
        self.base_coord = _cast(int, base_coord)
        if BASECALL is None:
            self.BASECALL = []
        else:
            self.BASECALL = BASECALL
    def factory(*args_, **kwargs_):
        if EXPECTED_BASECALL_TABLEType.subclass:
            return EXPECTED_BASECALL_TABLEType.subclass(*args_, **kwargs_)
        else:
            return EXPECTED_BASECALL_TABLEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_BASECALL(self): return self.BASECALL
    def set_BASECALL(self, BASECALL): self.BASECALL = BASECALL
    def add_BASECALL(self, value): self.BASECALL.append(value)
    def insert_BASECALL_at(self, index, value): self.BASECALL.insert(index, value)
    def replace_BASECALL_at(self, index, value): self.BASECALL[index] = value
    def get_default_length(self): return self.default_length
    def set_default_length(self, default_length): self.default_length = default_length
    def get_base_coord(self): return self.base_coord
    def set_base_coord(self, base_coord): self.base_coord = base_coord
    def hasContent_(self):
        if (
            self.BASECALL
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='EXPECTED_BASECALL_TABLEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='EXPECTED_BASECALL_TABLEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='EXPECTED_BASECALL_TABLEType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='EXPECTED_BASECALL_TABLEType'):
        if self.default_length is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            outfile.write(' default_length="%s"' % self.gds_format_integer(self.default_length, input_name='default_length'))
        if self.base_coord is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            outfile.write(' base_coord="%s"' % self.gds_format_integer(self.base_coord, input_name='base_coord'))
    def exportChildren(self, outfile, level, namespace_='', name_='EXPECTED_BASECALL_TABLEType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for BASECALL_ in self.BASECALL:
            BASECALL_.export(outfile, level, namespace_, name_='BASECALL', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='EXPECTED_BASECALL_TABLEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.default_length is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            showIndent(outfile, level)
            outfile.write('default_length=%d,\n' % (self.default_length,))
        if self.base_coord is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            showIndent(outfile, level)
            outfile.write('base_coord=%d,\n' % (self.base_coord,))
    def exportLiteralChildren(self, outfile, level, name_):
        showIndent(outfile, level)
        outfile.write('BASECALL=[\n')
        level += 1
        for BASECALL_ in self.BASECALL:
            showIndent(outfile, level)
            outfile.write('model_.BASECALLType(\n')
            BASECALL_.exportLiteral(outfile, level, name_='BASECALLType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('default_length', node)
        if value is not None and 'default_length' not in already_processed:
            already_processed.add('default_length')
            try:
                self.default_length = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.default_length < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('base_coord', node)
        if value is not None and 'base_coord' not in already_processed:
            already_processed.add('base_coord')
            try:
                self.base_coord = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.base_coord < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'BASECALL':
            obj_ = BASECALLType.factory()
            obj_.build(child_)
            self.BASECALL.append(obj_)
            obj_.original_tagname_ = 'BASECALL'
# end class EXPECTED_BASECALL_TABLEType


class BASECALLType(GeneratedsSuper):
    """When match occurs, the read will be tagged with this group
    membership Minimum number of matches to trigger identification.
    Maximum number of mismatches Where the match should occur.
    Changes the rules on how min_match and max_mismatch are counted.
    Only @max_mismatch influences matching process Both matches and
    mismatches are counted. When @max_mismatch is exceeded - it is
    not a match. When @min_match is reached - match is declared.
    Both matches and mismatches are counted. When @max_mismatch is
    exceeded - it is not a match. When @min_match is reached - match
    is declared."""
    subclass = None
    superclass = None
    def __init__(self, max_mismatch=None, min_match=None, match_edge=None, read_group_tag=None, valueOf_=None):
        self.original_tagname_ = None
        self.max_mismatch = _cast(int, max_mismatch)
        self.min_match = _cast(int, min_match)
        self.match_edge = _cast(None, match_edge)
        self.read_group_tag = _cast(None, read_group_tag)
        self.valueOf_ = valueOf_
    def factory(*args_, **kwargs_):
        if BASECALLType.subclass:
            return BASECALLType.subclass(*args_, **kwargs_)
        else:
            return BASECALLType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_max_mismatch(self): return self.max_mismatch
    def set_max_mismatch(self, max_mismatch): self.max_mismatch = max_mismatch
    def get_min_match(self): return self.min_match
    def set_min_match(self, min_match): self.min_match = min_match
    def get_match_edge(self): return self.match_edge
    def set_match_edge(self, match_edge): self.match_edge = match_edge
    def get_read_group_tag(self): return self.read_group_tag
    def set_read_group_tag(self, read_group_tag): self.read_group_tag = read_group_tag
    def get_valueOf_(self): return self.valueOf_
    def set_valueOf_(self, valueOf_): self.valueOf_ = valueOf_
    def hasContent_(self):
        if (
            self.valueOf_
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BASECALLType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BASECALLType')
        if self.hasContent_():
            outfile.write('>')
            outfile.write(str(self.valueOf_).encode(ExternalEncoding))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BASECALLType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BASECALLType'):
        if self.max_mismatch is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            outfile.write(' max_mismatch="%s"' % self.gds_format_integer(self.max_mismatch, input_name='max_mismatch'))
        if self.min_match is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            outfile.write(' min_match="%s"' % self.gds_format_integer(self.min_match, input_name='min_match'))
        if self.match_edge is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            outfile.write(' match_edge=%s' % (self.gds_format_string(quote_attrib(self.match_edge).encode(ExternalEncoding), input_name='match_edge'), ))
        if self.read_group_tag is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            outfile.write(' read_group_tag=%s' % (self.gds_format_string(quote_attrib(self.read_group_tag).encode(ExternalEncoding), input_name='read_group_tag'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='BASECALLType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='BASECALLType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('valueOf_ = """%s""",\n' % (self.valueOf_,))
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.max_mismatch is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            showIndent(outfile, level)
            outfile.write('max_mismatch=%d,\n' % (self.max_mismatch,))
        if self.min_match is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            showIndent(outfile, level)
            outfile.write('min_match=%d,\n' % (self.min_match,))
        if self.match_edge is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            showIndent(outfile, level)
            outfile.write('match_edge="%s",\n' % (self.match_edge,))
        if self.read_group_tag is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            showIndent(outfile, level)
            outfile.write('read_group_tag="%s",\n' % (self.read_group_tag,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        self.valueOf_ = get_all_text_(node)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('max_mismatch', node)
        if value is not None and 'max_mismatch' not in already_processed:
            already_processed.add('max_mismatch')
            try:
                self.max_mismatch = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.max_mismatch < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('min_match', node)
        if value is not None and 'min_match' not in already_processed:
            already_processed.add('min_match')
            try:
                self.min_match = int(value)
            except ValueError as exp:
                raise_parse_error(node, 'Bad integer attribute: %s' % exp)
            if self.min_match < 0:
                raise_parse_error(node, 'Invalid NonNegativeInteger')
        value = find_attr_value_('match_edge', node)
        if value is not None and 'match_edge' not in already_processed:
            already_processed.add('match_edge')
            self.match_edge = value
        value = find_attr_value_('read_group_tag', node)
        if value is not None and 'read_group_tag' not in already_processed:
            already_processed.add('read_group_tag')
            self.read_group_tag = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class BASECALLType


class LS454Type(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_type454Model(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if LS454Type.subclass:
            return LS454Type.subclass(*args_, **kwargs_)
        else:
            return LS454Type(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_type454Model(self, value):
        # Validate type type454Model, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['454 GS', '454 GS 20', '454 GS FLX', '454 GS FLX+', '454 GS FLX Titanium', '454 GS Junior', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on type454Model' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='LS454Type', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='LS454Type')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='LS454Type', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='LS454Type'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='LS454Type', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='LS454Type'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type type454Model
            self.validate_type454Model(self.INSTRUMENT_MODEL)
# end class LS454Type


class ILLUMINAType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeIlluminaModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if ILLUMINAType.subclass:
            return ILLUMINAType.subclass(*args_, **kwargs_)
        else:
            return ILLUMINAType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeIlluminaModel(self, value):
        # Validate type typeIlluminaModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Illumina Genome Analyzer', 'Illumina Genome Analyzer II', 'Illumina Genome Analyzer IIx', 'Illumina HiSeq 2500', 'Illumina HiSeq 2000', 'Illumina HiSeq 1500', 'Illumina HiSeq 1000', 'Illumina MiSeq', 'Illumina HiScanSQ', 'HiSeq X Ten', 'NextSeq 500', 'HiSeq X Five', 'Illumina HiSeq 3000', 'Illumina HiSeq 4000', 'NextSeq 550', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeIlluminaModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ILLUMINAType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ILLUMINAType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ILLUMINAType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ILLUMINAType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ILLUMINAType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ILLUMINAType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeIlluminaModel
            self.validate_typeIlluminaModel(self.INSTRUMENT_MODEL)
# end class ILLUMINAType


class HELICOSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeHelicosModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if HELICOSType.subclass:
            return HELICOSType.subclass(*args_, **kwargs_)
        else:
            return HELICOSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeHelicosModel(self, value):
        # Validate type typeHelicosModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Helicos HeliScope', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeHelicosModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='HELICOSType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='HELICOSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='HELICOSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='HELICOSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='HELICOSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='HELICOSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeHelicosModel
            self.validate_typeHelicosModel(self.INSTRUMENT_MODEL)
# end class HELICOSType


class ABI_SOLIDType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeAbiSolidModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if ABI_SOLIDType.subclass:
            return ABI_SOLIDType.subclass(*args_, **kwargs_)
        else:
            return ABI_SOLIDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeAbiSolidModel(self, value):
        # Validate type typeAbiSolidModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AB SOLiD System', 'AB SOLiD System 2.0', 'AB SOLiD System 3.0', 'AB SOLiD 3 Plus System', 'AB SOLiD 4 System', 'AB SOLiD 4hq System', 'AB SOLiD PI System', 'AB 5500 Genetic Analyzer', 'AB 5500xl Genetic Analyzer', 'AB 5500xl-W Genetic Analysis System', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeAbiSolidModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ABI_SOLIDType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ABI_SOLIDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ABI_SOLIDType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ABI_SOLIDType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ABI_SOLIDType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ABI_SOLIDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeAbiSolidModel
            self.validate_typeAbiSolidModel(self.INSTRUMENT_MODEL)
# end class ABI_SOLIDType


class COMPLETE_GENOMICSType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeCGModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if COMPLETE_GENOMICSType.subclass:
            return COMPLETE_GENOMICSType.subclass(*args_, **kwargs_)
        else:
            return COMPLETE_GENOMICSType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeCGModel(self, value):
        # Validate type typeCGModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Complete Genomics', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeCGModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='COMPLETE_GENOMICSType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='COMPLETE_GENOMICSType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='COMPLETE_GENOMICSType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='COMPLETE_GENOMICSType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='COMPLETE_GENOMICSType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='COMPLETE_GENOMICSType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeCGModel
            self.validate_typeCGModel(self.INSTRUMENT_MODEL)
# end class COMPLETE_GENOMICSType


class BGISEQType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeBGISEQModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if BGISEQType.subclass:
            return BGISEQType.subclass(*args_, **kwargs_)
        else:
            return BGISEQType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeBGISEQModel(self, value):
        # Validate type typeBGISEQModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['BGISEQ-500']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeBGISEQModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='BGISEQType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='BGISEQType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='BGISEQType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='BGISEQType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='BGISEQType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='BGISEQType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeBGISEQModel
            self.validate_typeBGISEQModel(self.INSTRUMENT_MODEL)
# end class BGISEQType


class OXFORD_NANOPOREType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeOxfordNanoporeModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if OXFORD_NANOPOREType.subclass:
            return OXFORD_NANOPOREType.subclass(*args_, **kwargs_)
        else:
            return OXFORD_NANOPOREType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeOxfordNanoporeModel(self, value):
        # Validate type typeOxfordNanoporeModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['MinION', 'GridION', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeOxfordNanoporeModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='OXFORD_NANOPOREType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='OXFORD_NANOPOREType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='OXFORD_NANOPOREType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='OXFORD_NANOPOREType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='OXFORD_NANOPOREType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='OXFORD_NANOPOREType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeOxfordNanoporeModel
            self.validate_typeOxfordNanoporeModel(self.INSTRUMENT_MODEL)
# end class OXFORD_NANOPOREType


class PACBIO_SMRTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typePacBioModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if PACBIO_SMRTType.subclass:
            return PACBIO_SMRTType.subclass(*args_, **kwargs_)
        else:
            return PACBIO_SMRTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typePacBioModel(self, value):
        # Validate type typePacBioModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['PacBio RS', 'PacBio RS II', 'Sequel', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typePacBioModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PACBIO_SMRTType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PACBIO_SMRTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PACBIO_SMRTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PACBIO_SMRTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='PACBIO_SMRTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PACBIO_SMRTType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typePacBioModel
            self.validate_typePacBioModel(self.INSTRUMENT_MODEL)
# end class PACBIO_SMRTType


class ION_TORRENTType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeIontorrentModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if ION_TORRENTType.subclass:
            return ION_TORRENTType.subclass(*args_, **kwargs_)
        else:
            return ION_TORRENTType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeIontorrentModel(self, value):
        # Validate type typeIontorrentModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['Ion Torrent PGM', 'Ion Torrent Proton', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeIontorrentModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ION_TORRENTType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ION_TORRENTType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ION_TORRENTType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ION_TORRENTType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='ION_TORRENTType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='ION_TORRENTType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeIontorrentModel
            self.validate_typeIontorrentModel(self.INSTRUMENT_MODEL)
# end class ION_TORRENTType


class CAPILLARYType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, INSTRUMENT_MODEL=None):
        self.original_tagname_ = None
        self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
        self.validate_typeCapillaryModel(self.INSTRUMENT_MODEL)
    def factory(*args_, **kwargs_):
        if CAPILLARYType.subclass:
            return CAPILLARYType.subclass(*args_, **kwargs_)
        else:
            return CAPILLARYType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_INSTRUMENT_MODEL(self): return self.INSTRUMENT_MODEL
    def set_INSTRUMENT_MODEL(self, INSTRUMENT_MODEL): self.INSTRUMENT_MODEL = INSTRUMENT_MODEL
    def validate_typeCapillaryModel(self, value):
        # Validate type typeCapillaryModel, a restriction on xs:string.
        if value is not None and Validate_simpletypes_:
            value = str(value)
            enumerations = ['AB 3730xL Genetic Analyzer', 'AB 3730 Genetic Analyzer', 'AB 3500xL Genetic Analyzer', 'AB 3500 Genetic Analyzer', 'AB 3130xL Genetic Analyzer', 'AB 3130 Genetic Analyzer', 'AB 310 Genetic Analyzer', 'unspecified']
            enumeration_respectee = False
            for enum in enumerations:
                if value == enum:
                    enumeration_respectee = True
                    break
            if not enumeration_respectee:
                warnings_.warn('Value "%(value)s" does not match xsd enumeration restriction on typeCapillaryModel' % {"value" : value.encode("utf-8")} )
    def hasContent_(self):
        if (
            self.INSTRUMENT_MODEL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CAPILLARYType', namespacedef_=' xmlns:com="SRA.common" ', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CAPILLARYType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CAPILLARYType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CAPILLARYType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CAPILLARYType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sINSTRUMENT_MODEL>%s</%sINSTRUMENT_MODEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.INSTRUMENT_MODEL).encode(ExternalEncoding), input_name='INSTRUMENT_MODEL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='CAPILLARYType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.INSTRUMENT_MODEL is not None:
            showIndent(outfile, level)
            outfile.write('INSTRUMENT_MODEL=%s,\n' % quote_python(self.INSTRUMENT_MODEL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'INSTRUMENT_MODEL':
            INSTRUMENT_MODEL_ = child_.text
            INSTRUMENT_MODEL_ = self.gds_validate_string(INSTRUMENT_MODEL_, node, 'INSTRUMENT_MODEL')
            self.INSTRUMENT_MODEL = INSTRUMENT_MODEL_
            # validate type typeCapillaryModel
            self.validate_typeCapillaryModel(self.INSTRUMENT_MODEL)
# end class CAPILLARYType


class PIPE_SECTIONType(GeneratedsSuper):
    """Name of the processing pipeline section."""
    subclass = None
    superclass = None
    def __init__(self, section_name=None, STEP_INDEX=None, PREV_STEP_INDEX=None, PROGRAM=None, VERSION=None, NOTES=None):
        self.original_tagname_ = None
        self.section_name = _cast(None, section_name)
        self.STEP_INDEX = STEP_INDEX
        if PREV_STEP_INDEX is None:
            self.PREV_STEP_INDEX = []
        else:
            self.PREV_STEP_INDEX = PREV_STEP_INDEX
        self.PROGRAM = PROGRAM
        self.VERSION = VERSION
        self.NOTES = NOTES
    def factory(*args_, **kwargs_):
        if PIPE_SECTIONType.subclass:
            return PIPE_SECTIONType.subclass(*args_, **kwargs_)
        else:
            return PIPE_SECTIONType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_STEP_INDEX(self): return self.STEP_INDEX
    def set_STEP_INDEX(self, STEP_INDEX): self.STEP_INDEX = STEP_INDEX
    def get_PREV_STEP_INDEX(self): return self.PREV_STEP_INDEX
    def set_PREV_STEP_INDEX(self, PREV_STEP_INDEX): self.PREV_STEP_INDEX = PREV_STEP_INDEX
    def add_PREV_STEP_INDEX(self, value): self.PREV_STEP_INDEX.append(value)
    def insert_PREV_STEP_INDEX_at(self, index, value): self.PREV_STEP_INDEX.insert(index, value)
    def replace_PREV_STEP_INDEX_at(self, index, value): self.PREV_STEP_INDEX[index] = value
    def get_PROGRAM(self): return self.PROGRAM
    def set_PROGRAM(self, PROGRAM): self.PROGRAM = PROGRAM
    def get_VERSION(self): return self.VERSION
    def set_VERSION(self, VERSION): self.VERSION = VERSION
    def get_NOTES(self): return self.NOTES
    def set_NOTES(self, NOTES): self.NOTES = NOTES
    def get_section_name(self): return self.section_name
    def set_section_name(self, section_name): self.section_name = section_name
    def hasContent_(self):
        if (
            self.STEP_INDEX is not None or
            self.PREV_STEP_INDEX or
            self.PROGRAM is not None or
            self.VERSION is not None or
            self.NOTES is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PIPE_SECTIONType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PIPE_SECTIONType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PIPE_SECTIONType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PIPE_SECTIONType'):
        if self.section_name is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            outfile.write(' section_name=%s' % (self.gds_format_string(quote_attrib(self.section_name).encode(ExternalEncoding), input_name='section_name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PIPE_SECTIONType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.STEP_INDEX is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sSTEP_INDEX>%s</%sSTEP_INDEX>%s' % (namespace_, self.gds_format_string(quote_xml(self.STEP_INDEX).encode(ExternalEncoding), input_name='STEP_INDEX'), namespace_, eol_))
        for PREV_STEP_INDEX_ in self.PREV_STEP_INDEX:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPREV_STEP_INDEX>%s</%sPREV_STEP_INDEX>%s' % (namespace_, self.gds_format_string(quote_xml(PREV_STEP_INDEX_).encode(ExternalEncoding), input_name='PREV_STEP_INDEX'), namespace_, eol_))
        if self.PROGRAM is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sPROGRAM>%s</%sPROGRAM>%s' % (namespace_, self.gds_format_string(quote_xml(self.PROGRAM).encode(ExternalEncoding), input_name='PROGRAM'), namespace_, eol_))
        if self.VERSION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sVERSION>%s</%sVERSION>%s' % (namespace_, self.gds_format_string(quote_xml(self.VERSION).encode(ExternalEncoding), input_name='VERSION'), namespace_, eol_))
        if self.NOTES is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sNOTES>%s</%sNOTES>%s' % (namespace_, self.gds_format_string(quote_xml(self.NOTES).encode(ExternalEncoding), input_name='NOTES'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='PIPE_SECTIONType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.section_name is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            showIndent(outfile, level)
            outfile.write('section_name="%s",\n' % (self.section_name,))
    def exportLiteralChildren(self, outfile, level, name_):
        if self.STEP_INDEX is not None:
            showIndent(outfile, level)
            outfile.write('STEP_INDEX=%s,\n' % quote_python(self.STEP_INDEX).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('PREV_STEP_INDEX=[\n')
        level += 1
        for PREV_STEP_INDEX_ in self.PREV_STEP_INDEX:
            showIndent(outfile, level)
            outfile.write('%s,\n' % quote_python(PREV_STEP_INDEX_).encode(ExternalEncoding))
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
        if self.PROGRAM is not None:
            showIndent(outfile, level)
            outfile.write('PROGRAM=%s,\n' % quote_python(self.PROGRAM).encode(ExternalEncoding))
        if self.VERSION is not None:
            showIndent(outfile, level)
            outfile.write('VERSION=%s,\n' % quote_python(self.VERSION).encode(ExternalEncoding))
        if self.NOTES is not None:
            showIndent(outfile, level)
            outfile.write('NOTES=%s,\n' % quote_python(self.NOTES).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('section_name', node)
        if value is not None and 'section_name' not in already_processed:
            already_processed.add('section_name')
            self.section_name = value
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'STEP_INDEX':
            STEP_INDEX_ = child_.text
            STEP_INDEX_ = self.gds_validate_string(STEP_INDEX_, node, 'STEP_INDEX')
            self.STEP_INDEX = STEP_INDEX_
        elif nodeName_ == 'PREV_STEP_INDEX':
            PREV_STEP_INDEX_ = child_.text
            PREV_STEP_INDEX_ = self.gds_validate_string(PREV_STEP_INDEX_, node, 'PREV_STEP_INDEX')
            self.PREV_STEP_INDEX.append(PREV_STEP_INDEX_)
        elif nodeName_ == 'PROGRAM':
            PROGRAM_ = child_.text
            PROGRAM_ = self.gds_validate_string(PROGRAM_, node, 'PROGRAM')
            self.PROGRAM = PROGRAM_
        elif nodeName_ == 'VERSION':
            VERSION_ = child_.text
            VERSION_ = self.gds_validate_string(VERSION_, node, 'VERSION')
            self.VERSION = VERSION_
        elif nodeName_ == 'NOTES':
            NOTES_ = child_.text
            NOTES_ = self.gds_validate_string(NOTES_, node, 'NOTES')
            self.NOTES = NOTES_
# end class PIPE_SECTIONType


class STANDARDType(GeneratedsSuper):
    """A recognized name for the genome assembly.Identifies the genome
    assembly using an accession number and a sequence version."""
    subclass = None
    superclass = None
    def __init__(self, refname=None, accession=None):
        self.original_tagname_ = None
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)
    def factory(*args_, **kwargs_):
        if STANDARDType.subclass:
            return STANDARDType.subclass(*args_, **kwargs_)
        else:
            return STANDARDType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_refname(self): return self.refname
    def set_refname(self, refname): self.refname = refname
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='STANDARDType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='STANDARDType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='STANDARDType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='STANDARDType'):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding), input_name='refname'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='STANDARDType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='STANDARDType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            showIndent(outfile, level)
            outfile.write('refname="%s",\n' % (self.refname,))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.accession = ' '.join(self.accession.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class STANDARDType


class CUSTOMType(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, DESCRIPTION=None, URL_LINK=None):
        self.original_tagname_ = None
        self.DESCRIPTION = DESCRIPTION
        if URL_LINK is None:
            self.URL_LINK = []
        else:
            self.URL_LINK = URL_LINK
    def factory(*args_, **kwargs_):
        if CUSTOMType.subclass:
            return CUSTOMType.subclass(*args_, **kwargs_)
        else:
            return CUSTOMType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_DESCRIPTION(self): return self.DESCRIPTION
    def set_DESCRIPTION(self, DESCRIPTION): self.DESCRIPTION = DESCRIPTION
    def get_URL_LINK(self): return self.URL_LINK
    def set_URL_LINK(self, URL_LINK): self.URL_LINK = URL_LINK
    def add_URL_LINK(self, value): self.URL_LINK.append(value)
    def insert_URL_LINK_at(self, index, value): self.URL_LINK.insert(index, value)
    def replace_URL_LINK_at(self, index, value): self.URL_LINK[index] = value
    def hasContent_(self):
        if (
            self.DESCRIPTION is not None or
            self.URL_LINK
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='CUSTOMType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='CUSTOMType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='CUSTOMType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='CUSTOMType'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='CUSTOMType', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.DESCRIPTION is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sDESCRIPTION>%s</%sDESCRIPTION>%s' % (namespace_, self.gds_format_string(quote_xml(self.DESCRIPTION).encode(ExternalEncoding), input_name='DESCRIPTION'), namespace_, eol_))
        for URL_LINK_ in self.URL_LINK:
            URL_LINK_.export(outfile, level, namespace_, name_='URL_LINK', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='CUSTOMType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.DESCRIPTION is not None:
            showIndent(outfile, level)
            outfile.write('DESCRIPTION=%s,\n' % quote_python(self.DESCRIPTION).encode(ExternalEncoding))
        showIndent(outfile, level)
        outfile.write('URL_LINK=[\n')
        level += 1
        for URL_LINK_ in self.URL_LINK:
            showIndent(outfile, level)
            outfile.write('model_.URL_LINKType1(\n')
            URL_LINK_.exportLiteral(outfile, level, name_='URL_LINKType1')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'DESCRIPTION':
            DESCRIPTION_ = child_.text
            DESCRIPTION_ = self.gds_validate_string(DESCRIPTION_, node, 'DESCRIPTION')
            self.DESCRIPTION = DESCRIPTION_
        elif nodeName_ == 'URL_LINK':
            obj_ = URL_LINKType1.factory()
            obj_.build(child_)
            self.URL_LINK.append(obj_)
            obj_.original_tagname_ = 'URL_LINK'
# end class CUSTOMType


class URL_LINKType1(GeneratedsSuper):
    subclass = None
    superclass = None
    def __init__(self, LABEL=None, URL=None):
        self.original_tagname_ = None
        self.LABEL = LABEL
        self.URL = URL
    def factory(*args_, **kwargs_):
        if URL_LINKType1.subclass:
            return URL_LINKType1.subclass(*args_, **kwargs_)
        else:
            return URL_LINKType1(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_LABEL(self): return self.LABEL
    def set_LABEL(self, LABEL): self.LABEL = LABEL
    def get_URL(self): return self.URL
    def set_URL(self, URL): self.URL = URL
    def hasContent_(self):
        if (
            self.LABEL is not None or
            self.URL is not None
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='URL_LINKType1', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='URL_LINKType1')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='URL_LINKType1', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='URL_LINKType1'):
        pass
    def exportChildren(self, outfile, level, namespace_='', name_='URL_LINKType1', fromsubclass_=False, pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.LABEL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sLABEL>%s</%sLABEL>%s' % (namespace_, self.gds_format_string(quote_xml(self.LABEL).encode(ExternalEncoding), input_name='LABEL'), namespace_, eol_))
        if self.URL is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sURL>%s</%sURL>%s' % (namespace_, self.gds_format_string(quote_xml(self.URL).encode(ExternalEncoding), input_name='URL'), namespace_, eol_))
    def exportLiteral(self, outfile, level, name_='URL_LINKType1'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        pass
    def exportLiteralChildren(self, outfile, level, name_):
        if self.LABEL is not None:
            showIndent(outfile, level)
            outfile.write('LABEL=%s,\n' % quote_python(self.LABEL).encode(ExternalEncoding))
        if self.URL is not None:
            showIndent(outfile, level)
            outfile.write('URL=%s,\n' % quote_python(self.URL).encode(ExternalEncoding))
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        pass
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'LABEL':
            LABEL_ = child_.text
            LABEL_ = self.gds_validate_string(LABEL_, node, 'LABEL')
            self.LABEL = LABEL_
        elif nodeName_ == 'URL':
            URL_ = child_.text
            URL_ = self.gds_validate_string(URL_, node, 'URL')
            self.URL = URL_
# end class URL_LINKType1


class SEQUENCEType(GeneratedsSuper):
    """A recognized name for the reference sequence. Accession.version with
    version being mandatory This is how Reference Sequence is
    labeled in submission file(s). It is equivalent to SQ label in
    BAM. Optional when submitted file uses INSDC accession.version"""
    subclass = None
    superclass = None
    def __init__(self, label=None, refname=None, accession=None):
        self.original_tagname_ = None
        self.label = _cast(None, label)
        self.refname = _cast(None, refname)
        self.accession = _cast(None, accession)
    def factory(*args_, **kwargs_):
        if SEQUENCEType.subclass:
            return SEQUENCEType.subclass(*args_, **kwargs_)
        else:
            return SEQUENCEType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_label(self): return self.label
    def set_label(self, label): self.label = label
    def get_refname(self): return self.refname
    def set_refname(self, refname): self.refname = refname
    def get_accession(self): return self.accession
    def set_accession(self, accession): self.accession = accession
    def hasContent_(self):
        if (

        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SEQUENCEType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SEQUENCEType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SEQUENCEType', pretty_print=pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SEQUENCEType'):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            outfile.write(' label=%s' % (self.gds_format_string(quote_attrib(self.label).encode(ExternalEncoding), input_name='label'), ))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            outfile.write(' refname=%s' % (self.gds_format_string(quote_attrib(self.refname).encode(ExternalEncoding), input_name='refname'), ))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            outfile.write(' accession=%s' % (self.gds_format_string(quote_attrib(self.accession).encode(ExternalEncoding), input_name='accession'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='SEQUENCEType', fromsubclass_=False, pretty_print=True):
        pass
    def exportLiteral(self, outfile, level, name_='SEQUENCEType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.label is not None and 'label' not in already_processed:
            already_processed.add('label')
            showIndent(outfile, level)
            outfile.write('label="%s",\n' % (self.label,))
        if self.refname is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            showIndent(outfile, level)
            outfile.write('refname="%s",\n' % (self.refname,))
        if self.accession is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            showIndent(outfile, level)
            outfile.write('accession="%s",\n' % (self.accession,))
    def exportLiteralChildren(self, outfile, level, name_):
        pass
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('label', node)
        if value is not None and 'label' not in already_processed:
            already_processed.add('label')
            self.label = value
        value = find_attr_value_('refname', node)
        if value is not None and 'refname' not in already_processed:
            already_processed.add('refname')
            self.refname = value
        value = find_attr_value_('accession', node)
        if value is not None and 'accession' not in already_processed:
            already_processed.add('accession')
            self.accession = value
            self.accession = ' '.join(self.accession.split())
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        pass
# end class SEQUENCEType


class ExperimentType(ObjectType):
    """An Experiment specifies of what will be sequenced and how the
    sequencing will be performed. It does not contain results. An
    Experiment is composed of a design, a platform selection, and
    processing parameters."""
    subclass = None
    superclass = ObjectType
    def __init__(self, center_name=None, alias=None, broker_name=None, accession=None, IDENTIFIERS=None, TITLE=None, STUDY_REF=None, DESIGN=None, PLATFORM=None, PROCESSING=None, EXPERIMENT_LINKS=None, EXPERIMENT_ATTRIBUTES=None):
        self.original_tagname_ = None
        super(ExperimentType, self).__init__(center_name, alias, broker_name, accession, IDENTIFIERS, )
        self.TITLE = TITLE
        self.STUDY_REF = STUDY_REF
        self.DESIGN = DESIGN
        self.PLATFORM = PLATFORM
        self.PROCESSING = PROCESSING
        self.EXPERIMENT_LINKS = EXPERIMENT_LINKS
        self.EXPERIMENT_ATTRIBUTES = EXPERIMENT_ATTRIBUTES
    def factory(*args_, **kwargs_):
        if ExperimentType.subclass:
            return ExperimentType.subclass(*args_, **kwargs_)
        else:
            return ExperimentType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_TITLE(self): return self.TITLE
    def set_TITLE(self, TITLE): self.TITLE = TITLE
    def get_STUDY_REF(self): return self.STUDY_REF
    def set_STUDY_REF(self, STUDY_REF): self.STUDY_REF = STUDY_REF
    def get_DESIGN(self): return self.DESIGN
    def set_DESIGN(self, DESIGN): self.DESIGN = DESIGN
    def get_PLATFORM(self): return self.PLATFORM
    def set_PLATFORM(self, PLATFORM): self.PLATFORM = PLATFORM
    def get_PROCESSING(self): return self.PROCESSING
    def set_PROCESSING(self, PROCESSING): self.PROCESSING = PROCESSING
    def get_EXPERIMENT_LINKS(self): return self.EXPERIMENT_LINKS
    def set_EXPERIMENT_LINKS(self, EXPERIMENT_LINKS): self.EXPERIMENT_LINKS = EXPERIMENT_LINKS
    def get_EXPERIMENT_ATTRIBUTES(self): return self.EXPERIMENT_ATTRIBUTES
    def set_EXPERIMENT_ATTRIBUTES(self, EXPERIMENT_ATTRIBUTES): self.EXPERIMENT_ATTRIBUTES = EXPERIMENT_ATTRIBUTES
    def hasContent_(self):
        if (
            self.TITLE is not None or
            self.STUDY_REF is not None or
            self.DESIGN is not None or
            self.PLATFORM is not None or
            self.PROCESSING is not None or
            self.EXPERIMENT_LINKS is not None or
            self.EXPERIMENT_ATTRIBUTES is not None or
            super(ExperimentType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='ExperimentType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='ExperimentType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='ExperimentType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='ExperimentType'):
        super(ExperimentType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='ExperimentType')
    def exportChildren(self, outfile, level, namespace_='', name_='ExperimentType', fromsubclass_=False, pretty_print=True):
        super(ExperimentType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.TITLE is not None:
            showIndent(outfile, level, pretty_print)
            outfile.write('<%sTITLE>%s</%sTITLE>%s' % (namespace_, self.gds_format_string(quote_xml(self.TITLE).encode(ExternalEncoding), input_name='TITLE'), namespace_, eol_))
        if self.STUDY_REF is not None:
            self.STUDY_REF.export(outfile, level, namespace_, name_='STUDY_REF', pretty_print=pretty_print)
        if self.DESIGN is not None:
            self.DESIGN.export(outfile, level, namespace_, name_='DESIGN', pretty_print=pretty_print)
        if self.PLATFORM is not None:
            self.PLATFORM.export(outfile, level, namespace_, name_='PLATFORM', pretty_print=pretty_print)
        if self.PROCESSING is not None:
            self.PROCESSING.export(outfile, level, namespace_, name_='PROCESSING', pretty_print=pretty_print)
        if self.EXPERIMENT_LINKS is not None:
            self.EXPERIMENT_LINKS.export(outfile, level, namespace_, name_='EXPERIMENT_LINKS', pretty_print=pretty_print)
        if self.EXPERIMENT_ATTRIBUTES is not None:
            self.EXPERIMENT_ATTRIBUTES.export(outfile, level, namespace_, name_='EXPERIMENT_ATTRIBUTES', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='ExperimentType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(ExperimentType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(ExperimentType, self).exportLiteralChildren(outfile, level, name_)
        if self.TITLE is not None:
            showIndent(outfile, level)
            outfile.write('TITLE=%s,\n' % quote_python(self.TITLE).encode(ExternalEncoding))
        if self.STUDY_REF is not None:
            showIndent(outfile, level)
            outfile.write('STUDY_REF=model_.STUDY_REFType(\n')
            self.STUDY_REF.exportLiteral(outfile, level, name_='STUDY_REF')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.DESIGN is not None:
            showIndent(outfile, level)
            outfile.write('DESIGN=model_.LibraryType(\n')
            self.DESIGN.exportLiteral(outfile, level, name_='DESIGN')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PLATFORM is not None:
            showIndent(outfile, level)
            outfile.write('PLATFORM=model_.PlatformType(\n')
            self.PLATFORM.exportLiteral(outfile, level, name_='PLATFORM')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.PROCESSING is not None:
            showIndent(outfile, level)
            outfile.write('PROCESSING=model_.ProcessingType(\n')
            self.PROCESSING.exportLiteral(outfile, level, name_='PROCESSING')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EXPERIMENT_LINKS is not None:
            showIndent(outfile, level)
            outfile.write('EXPERIMENT_LINKS=model_.EXPERIMENT_LINKSType(\n')
            self.EXPERIMENT_LINKS.exportLiteral(outfile, level, name_='EXPERIMENT_LINKS')
            showIndent(outfile, level)
            outfile.write('),\n')
        if self.EXPERIMENT_ATTRIBUTES is not None:
            showIndent(outfile, level)
            outfile.write('EXPERIMENT_ATTRIBUTES=model_.EXPERIMENT_ATTRIBUTESType(\n')
            self.EXPERIMENT_ATTRIBUTES.exportLiteral(outfile, level, name_='EXPERIMENT_ATTRIBUTES')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(ExperimentType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'TITLE':
            TITLE_ = child_.text
            TITLE_ = self.gds_validate_string(TITLE_, node, 'TITLE')
            self.TITLE = TITLE_
        elif nodeName_ == 'STUDY_REF':
            obj_ = STUDY_REFType.factory()
            obj_.build(child_)
            self.STUDY_REF = obj_
            obj_.original_tagname_ = 'STUDY_REF'
        elif nodeName_ == 'DESIGN':
            obj_ = LibraryType.factory()
            obj_.build(child_)
            self.DESIGN = obj_
            obj_.original_tagname_ = 'DESIGN'
        elif nodeName_ == 'PLATFORM':
            obj_ = PlatformType.factory()
            obj_.build(child_)
            self.PLATFORM = obj_
            obj_.original_tagname_ = 'PLATFORM'
        elif nodeName_ == 'PROCESSING':
            obj_ = ProcessingType.factory()
            obj_.build(child_)
            self.PROCESSING = obj_
            obj_.original_tagname_ = 'PROCESSING'
        elif nodeName_ == 'EXPERIMENT_LINKS':
            obj_ = EXPERIMENT_LINKSType.factory()
            obj_.build(child_)
            self.EXPERIMENT_LINKS = obj_
            obj_.original_tagname_ = 'EXPERIMENT_LINKS'
        elif nodeName_ == 'EXPERIMENT_ATTRIBUTES':
            obj_ = EXPERIMENT_ATTRIBUTESType.factory()
            obj_.build(child_)
            self.EXPERIMENT_ATTRIBUTES = obj_
            obj_.original_tagname_ = 'EXPERIMENT_ATTRIBUTES'
        super(ExperimentType, self).buildChildren(child_, node, nodeName_, True)
# end class ExperimentType


class SampleDescriptorType(RefObjectType):
    subclass = None
    superclass = RefObjectType
    def __init__(self, accession=None, refname=None, refcenter=None, IDENTIFIERS=None, POOL=None):
        self.original_tagname_ = None
        super(SampleDescriptorType, self).__init__(accession, refname, refcenter, IDENTIFIERS, )
        self.POOL = POOL
    def factory(*args_, **kwargs_):
        if SampleDescriptorType.subclass:
            return SampleDescriptorType.subclass(*args_, **kwargs_)
        else:
            return SampleDescriptorType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_POOL(self): return self.POOL
    def set_POOL(self, POOL): self.POOL = POOL
    def hasContent_(self):
        if (
            self.POOL is not None or
            super(SampleDescriptorType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='SampleDescriptorType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='SampleDescriptorType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='SampleDescriptorType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='SampleDescriptorType'):
        super(SampleDescriptorType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='SampleDescriptorType')
    def exportChildren(self, outfile, level, namespace_='', name_='SampleDescriptorType', fromsubclass_=False, pretty_print=True):
        super(SampleDescriptorType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.POOL is not None:
            self.POOL.export(outfile, level, namespace_, name_='POOL', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='SampleDescriptorType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        super(SampleDescriptorType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(SampleDescriptorType, self).exportLiteralChildren(outfile, level, name_)
        if self.POOL is not None:
            showIndent(outfile, level)
            outfile.write('POOL=model_.POOLType(\n')
            self.POOL.exportLiteral(outfile, level, name_='POOL')
            showIndent(outfile, level)
            outfile.write('),\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        super(SampleDescriptorType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'POOL':
            obj_ = POOLType.factory()
            obj_.build(child_)
            self.POOL = obj_
            obj_.original_tagname_ = 'POOL'
        super(SampleDescriptorType, self).buildChildren(child_, node, nodeName_, True)
# end class SampleDescriptorType


class PoolMemberType(RefObjectType):
    """Label a sample within a scope of the pool Proportion of this sample
    (in percent) that was included in sample pool."""
    subclass = None
    superclass = RefObjectType
    def __init__(self, accession=None, refname=None, refcenter=None, IDENTIFIERS=None, proportion=None, member_name=None, READ_LABEL=None):
        self.original_tagname_ = None
        super(PoolMemberType, self).__init__(accession, refname, refcenter, IDENTIFIERS, )
        self.proportion = _cast(float, proportion)
        self.member_name = _cast(None, member_name)
        if READ_LABEL is None:
            self.READ_LABEL = []
        else:
            self.READ_LABEL = READ_LABEL
    def factory(*args_, **kwargs_):
        if PoolMemberType.subclass:
            return PoolMemberType.subclass(*args_, **kwargs_)
        else:
            return PoolMemberType(*args_, **kwargs_)
    factory = staticmethod(factory)
    def get_READ_LABEL(self): return self.READ_LABEL
    def set_READ_LABEL(self, READ_LABEL): self.READ_LABEL = READ_LABEL
    def add_READ_LABEL(self, value): self.READ_LABEL.append(value)
    def insert_READ_LABEL_at(self, index, value): self.READ_LABEL.insert(index, value)
    def replace_READ_LABEL_at(self, index, value): self.READ_LABEL[index] = value
    def get_proportion(self): return self.proportion
    def set_proportion(self, proportion): self.proportion = proportion
    def get_member_name(self): return self.member_name
    def set_member_name(self, member_name): self.member_name = member_name
    def hasContent_(self):
        if (
            self.READ_LABEL or
            super(PoolMemberType, self).hasContent_()
        ):
            return True
        else:
            return False
    def export(self, outfile, level, namespace_='', name_='PoolMemberType', namespacedef_='', pretty_print=True):
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        if self.original_tagname_ is not None:
            name_ = self.original_tagname_
        showIndent(outfile, level, pretty_print)
        outfile.write('<%s%s%s' % (namespace_, name_, namespacedef_ and ' ' + namespacedef_ or '', ))
        already_processed = set()
        self.exportAttributes(outfile, level, already_processed, namespace_, name_='PoolMemberType')
        if self.hasContent_():
            outfile.write('>%s' % (eol_, ))
            self.exportChildren(outfile, level + 1, namespace_='', name_='PoolMemberType', pretty_print=pretty_print)
            showIndent(outfile, level, pretty_print)
            outfile.write('</%s%s>%s' % (namespace_, name_, eol_))
        else:
            outfile.write('/>%s' % (eol_, ))
    def exportAttributes(self, outfile, level, already_processed, namespace_='', name_='PoolMemberType'):
        super(PoolMemberType, self).exportAttributes(outfile, level, already_processed, namespace_, name_='PoolMemberType')
        if self.proportion is not None and 'proportion' not in already_processed:
            already_processed.add('proportion')
            outfile.write(' proportion="%s"' % self.gds_format_float(self.proportion, input_name='proportion'))
        if self.member_name is not None and 'member_name' not in already_processed:
            already_processed.add('member_name')
            outfile.write(' member_name=%s' % (self.gds_format_string(quote_attrib(self.member_name).encode(ExternalEncoding), input_name='member_name'), ))
    def exportChildren(self, outfile, level, namespace_='', name_='PoolMemberType', fromsubclass_=False, pretty_print=True):
        super(PoolMemberType, self).exportChildren(outfile, level, namespace_, name_, True, pretty_print=pretty_print)
        if pretty_print:
            eol_ = '\n'
        else:
            eol_ = ''
        for READ_LABEL_ in self.READ_LABEL:
            READ_LABEL_.export(outfile, level, namespace_, name_='READ_LABEL', pretty_print=pretty_print)
    def exportLiteral(self, outfile, level, name_='PoolMemberType'):
        level += 1
        already_processed = set()
        self.exportLiteralAttributes(outfile, level, already_processed, name_)
        if self.hasContent_():
            self.exportLiteralChildren(outfile, level, name_)
    def exportLiteralAttributes(self, outfile, level, already_processed, name_):
        if self.proportion is not None and 'proportion' not in already_processed:
            already_processed.add('proportion')
            showIndent(outfile, level)
            outfile.write('proportion=%f,\n' % (self.proportion,))
        if self.member_name is not None and 'member_name' not in already_processed:
            already_processed.add('member_name')
            showIndent(outfile, level)
            outfile.write('member_name="%s",\n' % (self.member_name,))
        super(PoolMemberType, self).exportLiteralAttributes(outfile, level, already_processed, name_)
    def exportLiteralChildren(self, outfile, level, name_):
        super(PoolMemberType, self).exportLiteralChildren(outfile, level, name_)
        showIndent(outfile, level)
        outfile.write('READ_LABEL=[\n')
        level += 1
        for READ_LABEL_ in self.READ_LABEL:
            showIndent(outfile, level)
            outfile.write('model_.READ_LABELType(\n')
            READ_LABEL_.exportLiteral(outfile, level, name_='READ_LABELType')
            showIndent(outfile, level)
            outfile.write('),\n')
        level -= 1
        showIndent(outfile, level)
        outfile.write('],\n')
    def build(self, node):
        already_processed = set()
        self.buildAttributes(node, node.attrib, already_processed)
        for child in node:
            nodeName_ = Tag_pattern_.match(child.tag).groups()[-1]
            self.buildChildren(child, node, nodeName_)
        return self
    def buildAttributes(self, node, attrs, already_processed):
        value = find_attr_value_('proportion', node)
        if value is not None and 'proportion' not in already_processed:
            already_processed.add('proportion')
            try:
                self.proportion = float(value)
            except ValueError as exp:
                raise ValueError('Bad float/double attribute (proportion): %s' % exp)
        value = find_attr_value_('member_name', node)
        if value is not None and 'member_name' not in already_processed:
            already_processed.add('member_name')
            self.member_name = value
        super(PoolMemberType, self).buildAttributes(node, attrs, already_processed)
    def buildChildren(self, child_, node, nodeName_, fromsubclass_=False):
        if nodeName_ == 'READ_LABEL':
            obj_ = READ_LABELType.factory()
            obj_.build(child_)
            self.READ_LABEL.append(obj_)
            obj_.original_tagname_ = 'READ_LABEL'
        super(PoolMemberType, self).buildChildren(child_, node, nodeName_, True)
# end class PoolMemberType


GDSClassesMapping = {
    'IDENTIFIERS': IdentifierType,
    'OXFORD_NANOPORE': OXFORD_NANOPOREType,
    'SPOT_DESCRIPTOR': SpotDescriptorType,
    'SINGLE': SINGLEType,
    'ABI_SOLID': ABI_SOLIDType,
    'DESIGN': LibraryType,
    'EXPERIMENT_ATTRIBUTES': EXPERIMENT_ATTRIBUTESType,
    'CUSTOM': CUSTOMType,
    'TARGETED_LOCI': TARGETED_LOCIType,
    'EXPERIMENT_SET': ExperimentSetType,
    'LS454': LS454Type,
    'PROBE_SET': XRefType,
    'ILLUMINA': ILLUMINAType,
    'EXPERIMENT_LINK': LinkType,
    'EXPERIMENT_LINKS': EXPERIMENT_LINKSType,
    'PRIMARY_ID': NameType,
    'PLATFORM': PlatformType,
    'RELATIVE_ORDER': RELATIVE_ORDERType,
    'PIPE_SECTION': PIPE_SECTIONType,
    'HELICOS': HELICOSType,
    'ENTREZ_LINK': ENTREZ_LINKType,
    'XREF_LINK': XRefType,
    'CAPILLARY': CAPILLARYType,
    'DEFAULT_MEMBER': PoolMemberType,
    'SAMPLE_DESCRIPTOR': SampleDescriptorType,
    'ASSEMBLY': ReferenceAssemblyType,
    'SEQUENCE': SEQUENCEType,
    'PROCESSING': ProcessingType,
    'STANDARD': STANDARDType,
    'PACBIO_SMRT': PACBIO_SMRTType,
    'STUDY_REF': STUDY_REFType,
    'ION_TORRENT': ION_TORRENTType,
    'COMPLETE_GENOMICS': COMPLETE_GENOMICSType,
    'SPOT_DECODE_SPEC': SPOT_DECODE_SPECType,
    'EXPECTED_BASECALL_TABLE': EXPECTED_BASECALL_TABLEType,
    'BASECALL': BASECALLType,
    'POOL': POOLType,
    'LOCUS': LOCUSType,
    'EXPERIMENT_ATTRIBUTE': AttributeType,
    'PIPELINE': PipelineType,
    'UUID': NameType,
    'READ_LABEL': READ_LABELType,
    'MEMBER': PoolMemberType,
    'URL_LINK': URL_LINKType1,
    'SUBMITTER_ID': QualifiedNameType,
    'BGISEQ': BGISEQType,
    'SECONDARY_ID': NameType,
    'EXPERIMENT': ExperimentType,
    'DIRECTIVES': SequencingDirectivesType,
    'PAIRED': PAIREDType,
    'LIBRARY_LAYOUT': LIBRARY_LAYOUTType,
    'EXTERNAL_ID': QualifiedNameType,
    'LIBRARY_DESCRIPTOR': LibraryDescriptorType,
    'READ_SPEC': READ_SPECType,
}


USAGE_TEXT = """
Usage: python <Parser>.py [ -s ] <in_xml_file>
"""


def usage():
    print(USAGE_TEXT)
    sys.exit(1)


def get_root_tag(node):
    tag = Tag_pattern_.match(node.tag).groups()[-1]
    rootClass = GDSClassesMapping.get(tag)
    if rootClass is None:
        rootClass = globals().get(tag)
    return tag, rootClass


def parse(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PoolMemberType'
        rootClass = PoolMemberType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='',
            pretty_print=True)
    return rootObj


def parseEtree(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PoolMemberType'
        rootClass = PoolMemberType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    mapping = {}
    rootElement = rootObj.to_etree(None, name_=rootTag, mapping_=mapping)
    reverse_mapping = rootObj.gds_reverse_node_mapping(mapping)
    if not silence:
        content = etree_.tostring(
            rootElement, pretty_print=True,
            xml_declaration=True, encoding="utf-8")
        sys.stdout.write(content)
        sys.stdout.write('\n')
    return rootObj, rootElement, mapping, reverse_mapping


def parseString(inString, silence=False):
    from StringIO import StringIO
    parser = None
    doc = parsexml_(StringIO(inString), parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PoolMemberType'
        rootClass = PoolMemberType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('<?xml version="1.0" ?>\n')
        rootObj.export(
            sys.stdout, 0, name_=rootTag,
            namespacedef_='')
    return rootObj


def parseLiteral(inFileName, silence=False):
    parser = None
    doc = parsexml_(inFileName, parser)
    rootNode = doc.getroot()
    rootTag, rootClass = get_root_tag(rootNode)
    if rootClass is None:
        rootTag = 'PoolMemberType'
        rootClass = PoolMemberType
    rootObj = rootClass.factory()
    rootObj.build(rootNode)
    # Enable Python to collect the space used by the DOM.
    doc = None
    if not silence:
        sys.stdout.write('#from experiment_api import *\n\n')
        sys.stdout.write('import experiment_api as model_\n\n')
        sys.stdout.write('rootObj = model_.rootClass(\n')
        rootObj.exportLiteral(sys.stdout, 0, name_=rootTag)
        sys.stdout.write(')\n')
    return rootObj


def main():
    args = sys.argv[1:]
    if len(args) == 1:
        parse(args[0])
    else:
        usage()


if __name__ == '__main__':
    #import pdb; pdb.set_trace()
    main()


__all__ = [
    "ABI_SOLIDType",
    "AttributeType",
    "BASECALLType",
    "BGISEQType",
    "CAPILLARYType",
    "COMPLETE_GENOMICSType",
    "CUSTOMType",
    "ENTREZ_LINKType",
    "EXPECTED_BASECALL_TABLEType",
    "EXPERIMENT_ATTRIBUTESType",
    "EXPERIMENT_LINKSType",
    "ExperimentSetType",
    "ExperimentType",
    "HELICOSType",
    "ILLUMINAType",
    "ION_TORRENTType",
    "IdentifierType",
    "LIBRARY_LAYOUTType",
    "LOCUSType",
    "LS454Type",
    "LibraryDescriptorType",
    "LibraryType",
    "LinkType",
    "NameType",
    "OXFORD_NANOPOREType",
    "ObjectType",
    "PACBIO_SMRTType",
    "PAIREDType",
    "PIPE_SECTIONType",
    "POOLType",
    "PipelineType",
    "PlatformType",
    "PoolMemberType",
    "ProcessingType",
    "QualifiedNameType",
    "READ_LABELType",
    "READ_SPECType",
    "RELATIVE_ORDERType",
    "RefObjectType",
    "ReferenceAssemblyType",
    "ReferenceSequenceType",
    "SEQUENCEType",
    "SINGLEType",
    "SPOT_DECODE_SPECType",
    "STANDARDType",
    "STUDY_REFType",
    "SampleDescriptorType",
    "SequencingDirectivesType",
    "SpotDescriptorType",
    "TARGETED_LOCIType",
    "URLType",
    "URL_LINKType",
    "URL_LINKType1",
    "XRefType"
]
